git f0f698a54d020d297e33a46377e8cfc9ab9bc291

---

# Описание версий фреймворка

- [Политика поддержки старых версий](#support-policy)
- [Laravel 5.2](#laravel-5.2)
- [Laravel 5.1.11](#laravel-5.1.11)
- [Laravel 5.1.4](#laravel-5.1.4)
- [Laravel 5.1](#laravel-5.1)
- [Laravel 5.0](#laravel-5.0)

<a name="support-policy"></a>
## Политика поддержки старых версий

Для LTS-релизов, таких как Laravel 5.1, обновления выпускаются в течении 2х лет с начала выпуска. Обновления, связанные с безопасностью выпускаются в течении 3х лет после выпуска.

Обновления для обычных релизов выпускаются в течении 6 месяцев, а обновления связанные с безопасностью - в течении 1 года.

<a name="laravel-5.2"></a>
## Laravel 5.2

Основные новинки, появившиеся в этой версии: множественные драйвера аутентификации, неявная привязка моделей, упрощенные global scores в Eloquent, генерация контроллеров/шаблонов для аутентификации, группы посредников (middlewares), посредник ограничения числа запросов к сайту с одного IP, валидация массивов. Обо всём поподробнее. 

### Множественные драйвера аутентификации

В предыдущих версиях Laravel был только один драйвер аутентификации, основанный на сессиях, и вы не могли сделать и использовать другой.

В Laravel 5.2 вы можете определить свой драйвер аутентификации, или даже несколько и контролировать выполнение каждого драйвера. Например, можно требовать от пользователей-админов логиниться в админку в отдельной дополнительной форме.

### Создание файлов аутентификации

Вы можете создать шаблоны для логина, регистрации и т.п. при помощи одной команды:

    php artisan make:auth

Сss-классы шаблонов совместимы с css-фреймворком Bootstrap.

Также эта команда вносит необходимые изменения в файл роутов.

### Неявная привязка моделей

Неявная привязка моделей позволяет передать в параметры роута или контроллера экземпляр модели, основываясь на id, переданному в роуте:

    use App\User;

    Route::get('/user/{user}', function (User $user) {
        return $user;
    });

### Группы посредников

Группы посредников (middlewares) позволяют сгруппировывать посредники для обработки определённых роутов. Например, для обработки http-запросов обычных пользователей нам нужно проверять CSRF-токен, расшифровывать куки, чтобы получить данные об авторизации и т.п., в то время как для обработки запросов к API всего этого делать не нужно, а нужно только ограничить число запросов с одного ip, чтобы не перегружать сервис. В Laravel 5.2 вы можете сделать две группы посредников для этого - `web` и `api`:

    /**
     * The application's route middleware groups.
     *
     * @var array
     */
    protected $middlewareGroups = [
        'web' => [
            \App\Http\Middleware\EncryptCookies::class,
            \Illuminate\Cookie\Middleware\AddQueuedCookiesToResponse::class,
            \Illuminate\Session\Middleware\StartSession::class,
            \Illuminate\View\Middleware\ShareErrorsFromSession::class,
            \App\Http\Middleware\VerifyCsrfToken::class,
        ],

        'api' => [
            'throttle:60,1',
        ],
    ];

Группа посредников назначается роутам следующим образом:

    Route::group(['middleware' => ['web']], function () {
        //
    });

### Ограничение частоты запросов

В Laravel появился встроенный посредник органичения частоты http-запросов с одного ip-адреса. Он принимает в качестве параметров максимальное число запросов и число минут, за которые разрешено это число запросов. Например, чтобы установить ограничение в 60 запросов в минуту, вызов посредника будет записан так:

    Route::get('/api/users', ['middleware' => 'throttle:60,1', function () {
        //
    }]);

### Валидация массивов

В ключах, указываемых для валидации входных данных, теперь можно указывать символ `*`, который обозначает произвольную строку, что позволяет легко валидировать массивы значений. В данном примере будут провалидированы все подобные поля формы - `person[1][email]`, `person[2][email]` и т.п.  

    $validator = Validator::make($request->all(), [
        'person.*.email' => 'email|unique:users'
    ]);

Для определения сообщения об ошибке также можно использовать эту конструкцию:

    'custom' => [
        'person.*.email' => [
            'unique' => 'Каждый человек должен иметь уникальный email',
        ]
    ],

### Правило валидации - bail

Добавлено новое правило валидации - `bail`. Фактически, это команда валидатору прекратить проверку последующих правил валидации, если проверка очередного правила вернула `false`. Например, здесь проверка на уникальность не будет выполнена, если user_id не является целым числом:

    $this->validate($request, [
        'user_id' => 'bail|integer|unique:users'
    ]);

### Улучшения глобальный условий Eloquent 

В предыдущих версиях Laravel глобальные условия (global scope) Eloquent были сложны в использовании, при использовании можно было легко допустить ошибку. В Laravel 5.2 ваши классы глобальных условий должны имплементировать всего один метод - `apply`.

Чтобы узнать больше, обратитесь к соответствующему разделу [документации](/docs/{{version}}/eloquent#global-scopes).

<a name="laravel-5.1.11"></a>
## Laravel 5.1.11

В Laravel появилась встроенная авторизация - разграничение прав доступа, основанное на разрешениях. [Документация](/docs/{{version}}/authorization).

<a name="laravel-5.1.4"></a>
## Laravel 5.1.4

В Laravel 5.1.4 появился встроенный троттлинг логина (ограничение числа неудачных попыток за единицу времени). [Документация](/docs/{{version}}/authentication#authentication-throttling).

<a name="laravel-5.1"></a>
## Laravel 5.1

Laravel 5.1 continues the improvements made in Laravel 5.0 by adopting PSR-2 and adding event broadcasting, middleware parameters, Artisan improvements, and more.

ВLaravel 5.1 является продолжением развития идей, заложенных в 5.0 - более полная поддержка PSR-2, добавление бродкаст(широковещательных)-событий, параметров к посредникам, улучшение инструмента командной строки artisan и т.п.

### PHP 5.5.9+

Laravel 5.1 требует для работы PHP версии 5.5.9 или выше. 

### LTS

Laravel 5.1 - это первый релиз Laravel с расширенной поддержкой (LTS). Это значит, что обновления для него будут выпускаться в течении 2х лет, а обновления, связанные с безопасностью - в течении 3х лет. Эта версия наиболее подходит для энтерпрайз-приложений.

### PSR-2

[PSR-2 coding style guide](https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-2-coding-style-guide.md) является дефолтным стайлгайдом написания кода в Laravel. Все генераторы кода в Laravel теперь следуют этому стандарту.

### Бродкастинг

В современных приложениях все чаще используются вебсокеты для организации реалтаймовой работы. Например, при изменений данных на сервере, по заданным вебсокет-соединениям отправляется уведомление о совершённой операции. Для реализации такого функционала в Laravel введены так называемый бродкастинг, т.е. широковещательную рассылку уведомлений по вебсокетам. 

Чтобы узнать больше, обратитесь к соответствующему разделу [документации](/docs/{{version}}/events#broadcasting-events).

### Параметры в посредниках

Посредники (middlewares) теперь могут принимать параметры. Например, нам надо проверить, что пользователь обладает определёнными правами для совершения действия. Метод `handle` класса `RoleMiddleware` обзавелся третьим аргументом, где мы можем передавать параметры для данного посредника, в нашем случае - название роли.

    <?php

    namespace App\Http\Middleware;

    use Closure;

    class RoleMiddleware
    {
        /**
         * Run the request filter.
         *
         * @param  \Illuminate\Http\Request  $request
         * @param  \Closure  $next
         * @param  string  $role
         * @return mixed
         */
        public function handle($request, Closure $next, $role)
        {
            if (! $request->user()->hasRole($role)) {
                // Redirect...
            }

            return $next($request);
        }

    }

Параметры для посредника передаются после символа `:`. Если параметров несколько, они разделяются символом `,`.

    Route::put('post/{id}', ['middleware' => 'role:editor', function ($id) {
        //
    }]);

Чтобы узнать больше, обратитесь к соответствующему разделу [документации](/docs/{{version}}/middleware).

### Новые возможности для тестирования

Встроенные средства тестирования подверглись кардинальному улучшению. Например, для функционального тестирования приложения можно использовать такой синтаксис:

    public function testNewUserRegistration()
    {
        $this->visit('/register')
             ->type('Taylor', 'name')
             ->check('terms')
             ->press('Register')
             ->seePageIs('/dashboard');
    }

Чтобы узнать больше, обратитесь к соответствующему разделу [документации](/docs/{{version}}/testing).

### Фабрики моделей

При помощи так называемых [фабрик моделей](/docs/{{version}}/testing#model-factories) вы можете определять дефолтные значения полей моделей, которые будут заполняться при создании экземпляров моделей. Обычно это используется во время тестирования. Фабрики используют в своей работе пакет [Faker](https://github.com/fzaninotto/Faker) для генерации случайных данных.

    $factory->define(App\User::class, function ($faker) {
        return [
            'name' => $faker->name,
            'email' => $faker->email,
            'password' => str_random(10),
            'remember_token' => str_random(10),
        ];
    });

Чтобы узнать больше, обратитесь к соответствующему разделу [документации](/docs/{{version}}/testing#model-factories).

### Улучшения artisan

Определять команды artisan стало гораздо проще - иеперь можно использовать следующий синтаксис, указывая аргументы и опции в фигурных скобках:

    /**
     * The name and signature of the console command.
     *
     * @var string
     */
    protected $signature = 'email:send {user} {--force}';

Чтобы узнать больше, обратитесь к соответствующему разделу [документации](/docs/{{version}}/artisan).

### Структура папок

Папка `app/Commands` переименована в `app/Jobs`. Обработчики событий теперь находятся не в папке `app/Handlers`, а в `app/Listeners`. Но, если хотите, вы можете держать обработчики на прежних местах, это не обязательное условие. 

### Шифрование

В предыдущих версиях Laravel использовалось шифрование при помощи расширения `mcrypt`. Начиная с 5.1 шифрование обеспечивается при помощи расширения `openssl`.

<a name="laravel-5.0"></a>
## Laravel 5.0

В Laravel 5.0 изменена дефолтная структура приложения. Теперь все приложение входит в стандарт автоматической загрузки PSR-4 целиком и является более подходящей основой для построения надежного приложения. Рассмотрим основные изменения:

### Новая структура папок

Папки `app/models` больше нет. Теперь все ваши классы живут в папке `app`, и по умолчанию находятся в неймспейсе `App`. Название неймспейса хранится в файле `config/namespaces.php` и его можно изменить во всех ваших классах сразу артизан-командой `php artisan app:name`.

Контроллеры, middlewares (посредники, обработчики HTTP-запросов) и requests (новый вид классов в Laravel 5.0) сгруппированы в папке `app/Http` как классы, относящиеся к HTTP-слою вашего приложения. Вместо файла фильтров роутов теперь во фреймворке используются middlewares, которые находятся каждый в своём файле.

Новая папка `app/Providers` является заменой папки `app/start` в предыдущих версиях Laravel 4.x. В этой папке находятся сервис-провайдеры, которые осуществляют инициализацию приложения - регистрацию классов-обработчиков ошибок, настройку логирования, загрузку файла роутов (маршрутов) и т.п. И, конечно, ваши сервис-провайдеры тоже могут находиться там.

Файлы локализаций (lang) и файлы шаблонов (views) теперь находятся в папке `resources`.

### Контракты

Все основные компоненты Laravel реализуют интерфейсы, размещенные в репозитории `illuminate/contracts`. У этого репозитория нет внешних зависимостей, это скелет фреймворка. Этот удобный корневой набор интерфейсов, который вы можете использовать в DI (dependency injection) своих классов, может служить альтернативой фасадам.

[Документация по контрактам](/docs/{{version}}/contracts).

### Кэширование роутов

Если ваше приложение использует много роутов, то для ускорения их обработки вы можете использовать artisan-команду `route:cache`. Эту команду можно применять на рабочем (продакшн) сервере после развёртывания (деплоя) приложения.

### Middleware

В Laravel 5 появились так называемые middlewares, посредники, которые выполняют роль, которая раньше возлагалась на фильтры роутов. Фильтры роутов продолжают поддерживаться, но все встроенные фильтры HTTP-запросов, как то CSRF-фильтрация, проверка аутентификации, переехали в middlewares. Свои обработчики HTTP-запроса тоже лучше писать в виде middlewares.

[Документация по middleware](/docs/{{version}}/middleware).

### DI (dependency injection) в методах контроллеров

Основной способ передачи классов для использования в вашем контроллере - указать их (type-hint) в аргументах конструктора вашего контроллера. Так как Laravel создает контроллеры и другие классы фреймворка при помощи [сервис-контейнера](/docs/{{version}}/container), он автоматически создает ожидаемые в аргументах конструктора классы и автоматически же подставляет их в вызов контроллера.

Теперь все вышеописанное работает не только для конструктора контроллера, но и для всех его методов.

	public function createPost(Request $request, PostRepository $posts)
	{
		//
	}

### Аутентификация из коробки

Laravel 5 содержит все необходимые миграции, контроллеры, модели и шаблоны для организации регистрации, аутентификации и смены пароля пользователя. Шаблоны находятся в `resources/views/auth`, валидация - `App\Services\Auth\Registrar`, контроллеры - в папке `app\Http\Controllers\Auth`. Теперь не нужно для каждого проекта писать код аутентификации, или копировать его из проекта в проект.

### События-объекты

Теперь вы можете определить событие (event) как объект:

	class PodcastWasPurchased {

		public $podcast;

		public function __construct(Podcast $podcast)
		{
			$this->podcast = $podcast;
		}

	}

Запуск события осуществляется как обычно, только теперь вместо строки-имени события можно использовать экземпляр события-объекта:

	Event::fire(new PodcastWasPurchased($podcast));

Конечно, ваш обработчик события в таком случае должен принимать объект вместо произвольной переменной `$data`:

	class ReportPodcastPurchase {

		public function handle(PodcastWasPurchased $event)
		{
			//
		}

	}

[Документация по событиям](/docs/{{version}}/events).

### Командная шина

В дополнение к задачам (job), помещаемым в очередь, которые вы использовали в Laravel 4, Laravel 5 предлагает концепцию команд, запускаемых через так называемую командную шину (command bus). Команды находятся в папке `app/Commands` и их тоже можно помещать в очередь (а можно и выполнять в текущем запросе). Вот пример команды:

	class PurchasePodcast extends Command implements SelfHandling, ShouldBeQueued {

		use SerializesModels;

		protected $user, $podcast;

		/**
		 * Создание объекта команды.
		 *
		 * @return void
		 */
		public function __construct(User $user, Podcast $podcast)
		{
			$this->user = $user;
			$this->podcast = $podcast;
		}

		/**
		 * Выполнение команды.
		 *
		 * @return void
		 */
		public function handle()
		{
			// Handle the logic to purchase the podcast...

			event(new PodcastWasPurchased($this->user, $this->podcast));
		}

	}


Базовый контроллер содержит трейт `DispatchesCommands` для выполнения команд:

	$this->dispatch(new PurchasePodcastCommand($user, $podcast));

Команды - прекрасное средство для разбивки функционала вашего приложения на изолированные части и разгрузки ваших контроллеров. 

[Документация по командной шине](/docs/{{version}}/bus)

### Реализация очереди в БД

Появился новый драйвер очереди - `database`. Теперь, если вы испытываете трудности с установкой дополнительного софта (Redis или Beanstalk) на ваш сервер, вы можете использовать таблицу MySQL для реализации очереди при помощи этого драйвера.

### Встроенный шедулер (периодический запуск команд)

In the past, developers have generated a Cron entry for each console command they wished to schedule. However, this is a headache. Your console schedule is no longer in source control, and you must SSH into your server to add the Cron entries. Let's make our lives easier. The Laravel command scheduler allows you to fluently and expressively define your command schedule within Laravel itself, and only a single Cron entry is needed on your server.

Раньше нам приходилось каждый скрипт, который должен был запускаться с определённой частотой или в определённое время, руками заносить в Cron, соединяясь с сервером по SSH, а при переезде на другой сервер - не забывать копировать его руками. С Laravel 5 жизнь стала проще. Теперь вы можете настраивать периодический запуск внутри вашего кода и хранить в системе контроля версий.

Вы только посмотрите, как это красиво:

	$schedule->command('artisan:command')->dailyAt('15:00');

[Документация по периодическому запуску команд](/docs/{{version}}/artisan#scheduling-artisan-commands).

### Tinker / Psysh

Команда `php artisan tinker` в Laravel 5 использует [Psysh](https://github.com/bobthecow/psysh) от Justin Hileman. Если вам нравился Boris в Laravel 4, вы полюбите и Psysh. Он лучше и работает под Windows! 

### DotEnv

В Laravel 5 больше нет папок для конфигов, специфичных для определённой среды выполнения. Все конфиги теперь хранятся в одной папке, а значения, специфичные среды выполнения хранятся в файле `.env`. Кроме того, название среды выполнения тоже задается в файле `.env` ! Больше никаких привязок к имени машины и флага `--env` в artisan-командах.
Laravel 5 использует библиотеку [DotEnv](https://github.com/vlucas/phpdotenv) от Vance Lucas. 

[Документация по настройке среды приложения](/docs/{{version}}/configuration#environment-configuration).

### Laravel Elixir

Laravel Elixir от Jeffrey Way - это инструмент для сборки css и js вашего приложения. Если вы слышали о Grunt или Gulp, но использование их казалось вам слишком сложным - попробуйте Elixir. Elixir представляет собой удобную надстройку над Gulp. С помощью него вы легко сможете компилировать Less, Sass или CoffeeScript. Он даже может автоматически запускать тесты за вас !

[Документация по Laravel Elixir](/docs/{{version}}/elixir).

### Laravel Socialite

Laravel Socialite - пакет, совместимый с Laravel 5.0+ для аутентификации на сайте через OAuth-провайдеры. Поддерживаются Facebook, Twitter, Google и GitHub:

	public function redirectForAuth()
	{
		return Socialize::with('twitter')->redirect();
	}

	public function getUserFromProvider()
	{
		$user = Socialize::with('twitter')->user();
	}

Больше нет нужды подбирать работающие библиотеки. Все просто работает! 

[Документация по аутентификации через соцсети](/docs/{{version}}/authentication#social-authentication).

### Облачная файловая система

Laravel 5 содержит [Flysystem](https://github.com/thephpleague/flysystem), пакет абстракции для работы с файловой системой, который поддерживает Amazon S3 и Rackspace Cloud Storage. Теперь вы можете одной строчкой в конфиге переключиться с хранения файлов на локальном диске на хранения файлов в облаке, так как функции работы с файлами не изменятся:

	Storage::put('file.txt', 'contents');

[Документация по Flysystem](/docs/{{version}}/filesystem).

### Form Requests

В Laravel 5.0 появились так называемые form requests. Это объект, который вместе с DI в методах контроллера, предлагает новый встроенный во фреймворк метод проверки и валидации пользовательского ввода. 

Например, реквест-класс формы регистрации:

	<?php namespace App\Http\Requests;

	class RegisterRequest extends FormRequest {

		public function rules()
		{
			return [
				'email' => 'required|email|unique:users',
				'password' => 'required|confirmed|min:8',
			];
		}

		public function authorize()
		{
			return true;
		}

	}

Далее вы вот так используете его в методе контроллера регистрации:

	public function register(RegisterRequest $request)
	{
		var_dump($request->input());
	}

Когда сервис-контейнер видит, что в метод контроллера подключается класс типа `FormRequest`, запускается **автоматическая валидация** пользовательского ввода по правилам, заявленным в подключаемом классе. Если валидация не проходит, произойдет автоматический редирект с передачей ошибок валидации через сессии. **Валидация форм еще никогда не была такой простой**. Узнать больше про реквест-классы можно в соответствующей главе [документации](/docs/{{version}}/validation#form-request-validation).

### Валидация в контроллерах

Если создавать файл form request на каждый запрос слишком накладно для вас, вы можете валидировать запрос прямо в контроллере. В Laravel 5 это стало еще проще. Теперь в базовом контроллере есть трейт `ValidatesRequests`, который предоставляет метод `validate`:

	public function createPost(Request $request)
	{
		$this->validate($request, [
			'title' => 'required|max:255',
			'body' => 'required',
		]);
	}

Вам не нужно контролировать результат валидации. Если валидация не удалась, фреймворк сам сделает редирект на предыдущую страницу, добавив в сессию сообщения об ошибках валидации и старый пользовательский ввод для отображения в форме. Или, если это был AJAX-запрос, вернёт соответствующий JSON.

[Документация по валидации в контроллерах](/docs/{{version}}/validation#controller-validation).

### Новые генераторы

У фреймворка появились новые команды генерации классов, моделей и т.п. Смотрите `php artisan list` чтобы узнать подробности.

### Кэш конфигов

You may now cache all of your configuration in a single file using the `config:cache` command.

Artisan-команда `config:cache` сливает конфиги в один файл для уменьшения количества операций чтения с диска. Рекомендуется использовать эту команду на рабочих (продакшн) серверах после развертывания (деплоя) приложения.

### VarDumper от Symfony

Хэлпер `dd` теперь использует прекрасный Symfony VarDumper, который раскрашивает дамп и позволяет схлопывать массивы. Посмотрите, как он работает:

	dd([1, 2, 3]);
