git b25d56c2f0551c2865e53819cf66eab94880a1d6

---

# Описание изменений

- [Схема контроля версий](#versioning-scheme)
- [Политика поддержки](#support-policy)
- [Laravel 5.4.22](#laravel-5.4.22)
- [Laravel 5.4](#laravel-5.4)
- [Laravel 5.3](#laravel-5.3)
- [Laravel 5.2](#laravel-5.2)
- [Laravel 5.1.11](#laravel-5.1.11)
- [Laravel 5.1.4](#laravel-5.1.4)
- [Laravel 5.1](#laravel-5.1)
- [Laravel 5.0](#laravel-5.0)
- [Laravel 4.2](#laravel-4.2)
- [Laravel 4.1](#laravel-4.1)

<a name="versioning-scheme"></a>
## Схема контроля версий

Схема контроля версий Laravel поддерживает соглашение именования версий `paradigm.minor.patch`. Малые релизы фремворка выпускаются каждые шесть месяцев (в январе и в июле), в то время как патчи могут выпускаться гораздо чаще, вплоть до каждой недели. Релизы патчей **никогда** не должны содержать критических изменений.

Когда вы ссылаетесь на структуру Laravel или ее компоненты из вашего приложения или пакета, вы всегда должны использовать ограничение версии, такое как `5.4.*`, так как второстепенные релизы Laravel не содержат критических изменений. Однако, мы стремимся всегда предоставить вам возможность обновиться до нового релиза в течение одного дня или быстрее.

Релизы меняющие парадигму - растягиваются на многие годы, и представляют собой фундаментальные изменения в архитектуре фреймворка и соглашениях. В настоящий момент в разработке нет релизов изменяющих парадигму.

#### Почему в Laravel не используется семантический контроль версий?

С одной стороны, все необязательные компоненты Laravel (Cashier, Dusk, Valet, Socialite, и т.д.) и **используют** семантический контроль версий. Однако, сам фреймворк Laravel - нет. Причина этого в том, что семантическое управление версиями является "редукционистским" способом определения совместимости двух фрагментов кода. Даже при использовании семантического контроля версий вам все еще нужно устанавливать обновленный пакет и запускать свой автоматический набор тестов, чтобы узнать о том, что что-либо *фактически* несовместимо с вашей базой кода.

Поэтому вместо этого фреймворк Laravel использует схему контроля версий, которая сообщает больше информации о фактическом охвате релиза. Помимо этого, так как релизы патчей **никогда** не содержат намеренные критические изменения; вы никогда не получите критическое изменение, если указываете требуемые версии в стиле конвенции `paradigm.minor.*`.

<a name="support-policy"></a>
## Политика поддержки

Для LTS-версий, таких как Laravel 5.1, обеспечивается исправление ошибок в течение 2 лет и исправление ошибок безопасности в течение 3 лет. Такие версии имеют наибольший срок поддержки. Для обычных релизов обеспечивается исправление ошибок в течение 6 месяцев и исправление ошибок безопасности в течение 1 года.

<a name="laravel-5.4.22"></a>
## Laravel 5.4.22

Laravel 5.4.22 исправляет уязвимость безопасности в серии релизов Laravel 5.4, которые позволяли выполнять попытки фишинга относительно пользователей приложения. Используя систему сброса пароля, злоумышленники могут попытаться обмануть ваших пользователей, указав их учетные данные для входа в отдельное приложение, которое они контролируют. Поскольку уведомление о сбросе пароля использует хост входящего запроса для создания URL-адреса сброса пароля, хост URL-адреса сброса пароля может быть подделан. Если пользователи не замечают, что они не находятся в домене их предполагаемого приложения, они могут случайно ввести свои учетные данные во вредоносном приложении.

В приложениях Laravel 5.1 уведомление о сбросе пароля находится в ведении разработчика, поэтому данной уязвимости может и не быть. Вы должны убедиться, что ваше приложение генерирует абсолютный URL для ссылок сброса пароля:

    {{ url('http://example.com/password/reset/'.$token) }}

<a name="laravel-5.4"></a>
## Laravel 5.4

Laravel 5.4 продолжает улучшения, внесенные в Laravel 5.3, добавляя поддержку [e-mail сообщений и уведомлений на основе markdown](/docs/5.4/mail#markdown-mailables), фреймворка для автоматизации браузера и тестирования [Laravel Dusk](/docs/5.4/dusk), Laravel Mix, "компоненты" и "слоты" Blade, привязку роут-моделей на каналах вещания, сообщения высшего порядка для Коллекций, объектно-ориентированные события Eloquent, настройки "retry" и "timeout" на уровне задач, "realtime"-фасады, улучшенную поддержку Redis Cluster, пользовательские модели сводных таблиц, посредников для запроса обрезки и очистки ввода, и др. Кроме того, вся кодовая база фреймворка прошла процедуру рефакторинга для улучшения общей опрятности кода.

> {tip} В этой документации приведены наиболее заметные улучшения фреймворка; более подробные списки изменений всегда доступны [на GitHub](https://github.com/laravel/framework/blob/5.4/CHANGELOG-5.4.md).

### Письма и уведомления в формате markdown

> {video} На Laracasts есть бесплатный [видео-урок](https://laracasts.com/series/whats-new-in-laravel-5-4/episodes/7) по этой теме.

Письма в формате markdown позволяют воспользоваться предварительно созданными шаблонами и компонентами почтовых уведомлений в ваших почтовых рассылках. Поскольку сообщения написаны в Markdown, Laravel может отображать красивые, отзывчивые HTML шаблоны для сообщений, в то же время генерируя копию с текстом без форматирования. Например, Markdown-email может выглядеть примерно так:

    @component('mail::message')
    # Order Shipped

    Ваш заказ был отправлен!

    @component('mail::button', ['url' => $url])
    Просмотреть заказ
    @endcomponent

    Следующие шаги:

    - Отследить заказ на нашем сайте
    - Заказать курьерскую доставку

    Спасибо,<br>
    {{ config('app.name') }}
    @endcomponent

Используя этот простой формат Markdown, Laravel может отображать красивые, отзывчивые HTML шаблоны для сообщений, в то же время генерируя копию с текстом без форматирования.:

<img src="https://laravel.com/assets/img/examples/markdown.png" width="551" height="596">

Чтобы прочитать больше о почтовых сообщениях и уведомлениях Markdown, советуем изучить документацию по [почтовым сообщениям](/docs/5.4/mail) и [уведомлениям](/docs/5.4/notifications).

> {tip} Вы можете экспортировать компоненты из почтовых сообщений в формате Markdown в собственное приложение, чтобы настроить их. Для экспорта компонентов используйте Artisan-камнду `vendor:publish`, чтобы опубликовать тег ассетов `laravel-mail`.

### Laravel Dusk

> {video} На Laracasts есть бесплатный [видео-урок](https://laracasts.com/series/whats-new-in-laravel-5-4/episodes/9) по этой теме.

Laravel Dusk предоставляет выразительный и простой в использовании API для тестирования и автоматизации с помощью браузера. По умолчанию Dusk не требует от вас установки JDK или Selenium на своей машине. Вместо этого Dusk использует отдельную установку [ChromeDriver](https://sites.google.com/a/chromium.org/chromedriver/home). Тем не менее, вы можете использовать и любой другой совместимый с Selenium драйвер по своему желанию.

Так как Dusk работает с реальным браузером, можно запросто тестировать и взаимодействовать со своими приложениями, в которых используется много скриптов:

    /**
     * Пример базового теста браузера.
     *
     * @return void
     */
    public function testBasicExample()
    {
        $user = factory(User::class)->create([
            'email' => 'taylor@laravel.com',
        ]);

        $this->browse(function ($browser) use ($user) {
            $browser->loginAs($user)
                    ->visit('/home')
                    ->press('Create Playlist')
                    ->whenAvailable('.playlist-modal', function ($modal) {
                        $modal->type('name', 'My Playlist')
                              ->press('Create');
                    });

            $browser->waitForText('Playlist Created');
        });
    }

Для получения дополнительной информации о Dusk смотрите [документацию Dusk](/docs/5.4/dusk).

### Laravel Mix

> {video} На Laracasts есть бесплатный [видео-урок](https://laracasts.com/series/whats-new-in-laravel-5-4/episodes/3) по этой теме.

Laravel Mix - духовный наследник Laravel Elixir, который полностью работает на Webpack вместо Gulp. Laravel Mix предоставляет API с текучим интерфейсом для определения шагов построения Webpack для вашего Laravel-приложения, используя несколько общих препроцессоров CSS и JavaScript. Вы можете задать свой конвейер ассетов простейшим методом связывания. Пример:

    mix.js('resources/assets/js/app.js', 'public/js')
       .sass('resources/assets/sass/app.scss', 'public/css');

### Компоненты и слоты Blade

> {video} На Laracasts есть бесплатный [видео-урок](https://laracasts.com/series/whats-new-in-laravel-5-4/episodes/6) по этой теме.

Компоненты и слоты предоставляют схожие плюсы для секций и разметки; однако, ментальные модели компонентов и слотов могут показаться многим проще для понимания. Во-первых, давайте представим повторно используемые компонент "alert", который мы бы хотели многократно использовать в нашем приложении:

    <!-- /resources/views/alert.blade.php -->

    <div class="alert alert-danger">
        {{ $slot }}
    </div>

Переменная `{{ $slot }}` будет содержать контент, который мы бы хотели внедрить в компонент. Теперь мы можем использовать Blade-директиву `@component` для построения этого компонента:

    @component('alert')
        <strong>Ой!</strong> Что-по пошло не так!
    @endcomponent

Именованные слоты позволяют вам предоставлять несколько слотов в едином компоненте:

    <!-- /resources/views/alert.blade.php -->

    <div class="alert alert-danger">
        <div class="alert-title">{{ $title }}</div>

        {{ $slot }}
    </div>

Именованные слоты можно внедрить, используя директиву `@slot`. Любой контент за рамками директивы `@slot` будет передан компоненту в переменной `$slot`:

    @component('alert')
        @slot('title')
            Forbidden
        @endslot

        Вам не разрешен доступ к этому ресурсу!
    @endcomponent

Загляните в полную [документацию Blade](/docs/5.4/blade), чтобы прочесть больше о компонентах и слотах.

### Присоединение модели к бродкастам

Как и HTTP роуты, роуты каналов теперь пользуются преимуществами [присоединения моделей к роутам](/docs/5.4/routing#route-model-binding), явных и скрытых. К примеру, вместо получения строки или числового ID заказа, вы можете запросить фактический экземпляр модели `Order`:

    use App\Order;

    Broadcast::channel('order.{order}', function ($user, Order $order) {
        return $user->id === $order->user_id;
    });

Чтобы прочитать больше о связывании моделей, см. полную документацию о [бродкасте событий](/docs/5.4/broadcasting).

### Операции высшего порядка в коллекциях

> {video} На Laracasts есть бесплатный [video tutorial](https://laracasts.com/series/whats-new-in-laravel-5-4/episodes/2) по этой теме.

Коллекции теперь поддерживают "операции высшего порядка", которые служат сокращенными методами для выполнения обычных действий с коллекциями. Методы коллекции, которые поддерживают операции высшего порядка: `contains`, `each`, `every`, `filter`, `first`, `map`, `partition`, `reject`, `sortBy`, `sortByDesc` и `sum`.

Доступ к каждой операции высшего порядка можно получить как к динамическому свойству экземпляра коллекции. Например, давайте используем сообщение высшего порядка `each`, чтобы вызвать метод для каждого объекта в коллекции:

    $users = User::where('votes', '>', 500)->get();

    $users->each->markAsVip();

Аналогично мы можем использовать операцию высшего порядка `sum`, чтобы собрать общее количество голосов ("votes") для коллекции пользователей:

    $users = User::where('group', 'Development')->get();

    return $users->sum->votes;

### Объектно-ориентированные события Eloquent

> {video} На Laracasts есть бесплатный [video tutorial](https://laracasts.com/series/whats-new-in-laravel-5-4/episodes/10) по этой теме.

Обработчики событий Eloquent теперь могут быть преобразованы в объекты событий. Это более интуитивный способ обработки событий Eloquent, который упрощает тестирование событий. Для начала задайте свойство `$events` в своей модели Eloquent, которая преобразовывает различные точки жизненного цикла Eloquent в ваши собственные [классы событий](/docs/5.4/events):

    <?php

    namespace App;

    use App\Events\UserSaved;
    use App\Events\UserDeleted;
    use Illuminate\Notifications\Notifiable;
    use Illuminate\Foundation\Auth\User as Authenticatable;

    class User extends Authenticatable
    {
        use Notifiable;

        /**
         * Карта событий для модели.
         *
         * @var array
         */
        protected $events = [
            'saved' => UserSaved::class,
            'deleted' => UserDeleted::class,
        ];
    }

### Настройки Retry и Timeout на уровне задач

Ранее настройки задач в очереди "retry" и "timeout" можно было настроить только глобально для всех задач в командной строке. Однако, в Laravel 5.4 данные настройки можно изменить отдельно для каждой задачи, задав их напрямую в классе задачи:

    <?php

    namespace App\Jobs;

    class ProcessPodcast implements ShouldQueue
    {
        /**
         * Количество раз, которое можно повторить задачу.
         *
         * @var int
         */
        public $tries = 5;

        /**
         * Количество секунд, которое задача может быть запущена до таймаута.
         *
         * @var int
         */
        public $timeout = 120;
    }

Для получения дополнительной информации см. [документацию по очередям](/docs/5.4/queues).

### Посредники для очистки запроса от опасных символов

> {video} На Laracasts есть бесплатный [видео-урок](https://laracasts.com/series/whats-new-in-laravel-5-4/episodes/1) по этой теме.

Laravel 5.4 включает два новых посредника в стеке посредников по умолчанию: `TrimStrings` и `ConvertEmptyStringsToNull`:

    /**
     * Глобальный стек HTTP-посредников приложения.
     *
     * Эти посредники запущены во время каждого запроса к вашему приложению.
     *
     * @var array
     */
    protected $middleware = [
        \Illuminate\Foundation\Http\Middleware\CheckForMaintenanceMode::class,
        \Illuminate\Foundation\Http\Middleware\ValidatePostSize::class,
        \App\Http\Middleware\TrimStrings::class,
        \Illuminate\Foundation\Http\Middleware\ConvertEmptyStringsToNull::class,
    ];

Эти посредники будут автоматически обрезать входные значения запроса и преобразовать любые пустые строки в `null`. Это поможет вам нормализовать ввод для каждого запроса, входящего в ваше приложение, и не беспокоиться о том, что постоянно нужно вызывать функцию `trim` на каждом роуте и контроллере.

### Фасады в реальном времени

> {video} На Laracasts есть бесплатный [видео-урок](https://laracasts.com/series/whats-new-in-laravel-5-4/episodes/8) по этой теме.

Ранее только собственные сервисы Laravel предоставляли [фасады](/docs/5.4/facades), которые обеспечивали быстрый, лаконичный доступ к своим методам через сервис-контейнер. Однако, в Laravel 5.4 можно запросто конвертировать любой класс вашего приложения в фасад в режиме реального времени просто добавив к имени импортированного класса `Facades` в роли префикса. Например, представьте, что ваше приложение содержит следующий класс:

    <?php

    namespace App\Services;

    class PaymentGateway
    {
        protected $tax;

        /**
         * Создание нового экземпляра шлюза платежа.
         *
         * @param  TaxCalculator  $tax
         * @return void
         */
        public function __construct(TaxCalculator $tax)
        {
            $this->tax = $tax;
        }

        /**
         * Заплатить заданную сумму.
         *
         * @param  int  $amount
         * @return void
         */
        public function pay($amount)
        {
            // Pay an amount...
        }
    }

Вы можете запросто использовать этот класс в качестве фасада:

    use Facades\ {
        App\Services\PaymentGateway
    };

    Route::get('/pay/{amount}', function ($amount) {
        PaymentGateway::pay($amount);
    });

Конечно, если вы используете фасад реального времени таким образом, вы можете легко написать тест для взаимодействия, используя [мок-возможности фасадов](/docs/5.4/mocking) Laravel:

    PaymentGateway::shouldReceive('pay')->with('100');

### Пользовательские модели сводных таблиц

В Laravel 5.3 все модели сводных ("pivot") таблиц для отношений `belongsToMany` используют один и тот же встроенный экземпляр модели `Pivot`. В Laravel 5.4 можно задать пользовательские модели для своих сводных таблиц. Если вы хотите определить пользовательскую модель для представления промежуточной таблицы ваших отношений, используйте метод `using` при определении отношения:

    <?php

    namespace App;

    use Illuminate\Database\Eloquent\Model;

    class Role extends Model
    {
        /**
         * Пользователи, которые принадлежат роли.
         */
        public function users()
        {
            return $this->belongsToMany('App\User')->using('App\UserRole');
        }
    }

### Улучшенная поддержка кластеров Redis

Раньше было невозможно определить соединения Redis к отдельным хостам и к кластерам в одном и том же приложении. В Laravel 5.4 теперь можно определять соединения Redis к нескольким одиночным хостам и к нескольким кластерам в рамках одного и того же приложения. Чтобы узнать больше о Redis в Laravel загляните в полную [документацию Redis](/docs/5.4/redis).

<a name="utf8mb4"></a>
### Миграция длины строки по умолчанию

Laravel 5.4 использует кодировку `utf8mb4`, установленную по умолчанию, которая включает поддержку "эмоджи" в базе данных. Если вы обновляете свое приложение с Laravel 5.3, вам не нужно переключаться на этот набор символов.

Если вы решите переключиться на этот набор символов вручную и работаете на версии MySQL старше релиза 5.7.7, то вам может потребоваться вручную настроить длину строки по умолчанию, используя миграции. Вы можете изменить данную настройку вызвав метод `Schema::defaultStringLength` в своем `AppServiceProvider`:

    use Illuminate\Support\Facades\Schema;

    /**
     * Bootstrap any application services.
     *
     * @return void
     */
    public function boot()
    {
        Schema::defaultStringLength(191);
    }

<a name="laravel-5.3"></a>
## Laravel 5.3

В Laravel 5.3 продолжены улучшения, сделанные в Laravel 5.2, добавлена [система уведомлений](/docs/5.3/notifications) на основе драйверов, надёжная поддержка режима реального времени с помощью [Laravel Echo](/docs/5.3/broadcasting), простая настройка серверов OAuth2 с помощью [Laravel Passport](/docs/5.3/passport), полнотекстовый поиск моделей с помощью [Laravel Scout](/docs/5.3/scout), поддержка Webpack в Laravel Elixir, «отправляемые по почте» объекты, явное разделение роутов `web` и `api`, консольные команды на основе замыканий, удобные вспомогательные функции для хранения загружаемых файлов, поддержка POPO и контроллеров одностороннего действия, улучшенная заготовка фронтенда по умолчанию, и многое другое.

### Уведомления

> {video} На Laracasts есть бесплатный [видео-урок](https://laracasts.com/series/whats-new-in-laravel-5-3/episodes/9) по этой теме.

Уведомления Laravel предоставляют простой, выразительный API для отправки уведомлений по различным каналам доставки, таким как email, Slack, SMS и другим. Например, вы можете определить уведомление об оплате счёта и доставлять его по email и SMS. Затем вы можете отправить уведомление с помощью одного простого метода:

    $user->notify(new InvoicePaid($invoice));

Для уведомлений уже существует огромное множество [созданных сообществом драйверов](http://laravel-notification-channels.com), включая поддержку уведомлений для iOS и Android. Подробнее об уведомлениях читайте в [полной документации по уведомлениям](/docs/5.3/notifications).

### WebSockets / Бродкаст событий

Вещание событий есть и в предыдущих версиях Laravel, но в Laravel 5.3 оно значительно улучшено добавлением аутентификации на уровне канала для частных каналов и каналов присутствия WebSocket:

    /*
     * Аутентификация подписки на канал...
     */
    Broadcast::channel('orders.*', function ($user, $orderId) {
        return $user->placedOrder($orderId);
    });

Laravel Echo — новый JavaScript-пакет, устанавливаемый через NPM. Он обеспечивает простой, прекрасный API для подписок на каналы и прослушивания ваших событий на стороне сервера в вашем JavaScript-приложении на стороне клиента. Echo включает поддержку [Pusher](https://pusher.com) и [Socket.io](http://socket.io):

    Echo.channel('orders.' + orderId)
        .listen('ShippingStatusUpdated', (e) => {
            console.log(e.description);
        });

В дополнение к подпискам на обычные каналы Laravel Echo упрощает подписку на каналы присутствия, которые предоставляют информацию о том, кто прослушивает данный канал:

    Echo.join('chat.' + roomId)
        .here((users) => {
            //
        })
        .joining((user) => {
            console.log(user.name);
        })
        .leaving((user) => {
            console.log(user.name);
        });

Подробнее об Echo и вещании событий читайте в [полной документации](/docs/5.3/broadcasting).

### Laravel Passport (Сервер OAuth2)

> {video} На Laracasts есть бесплатный [видео-урок](https://laracasts.com/series/whats-new-in-laravel-5-3/episodes/13) по этой теме.

В Laravel 5.3 реализована простая API аутентификация с помощью [Laravel Passport](/docs/{{version}}/passport), который предоставляет полную реализацию сервера OAuth2 для вашего приложения в считанные минуты. Passport создан на основе [сервера League OAuth2](https://github.com/thephpleague/oauth2-server), созданного Алексом Билби.

Passport упрощает создание токенов доступа с помощью кодов авторизации OAuth2. Также вы можете позволить своим пользователям создавать "персональные токены доступа" с помощью вашего веб-UI. Чтобы вы могли быстрее разобраться, Passport содержит [Vue-компоненты](https://vuejs.org), которые могут служить отправной точкой для вашей панели управления OAuth2, позволяя пользователям создавать клиентов, отзывать токены доступа и многое другое:

    <passport-clients></passport-clients>
    <passport-authorized-clients></passport-authorized-clients>
    <passport-personal-access-tokens></passport-personal-access-tokens>

Если вы не хотите использовать Vue-компоненты, вы можете предоставить свою собственную фронтенд-панель для управления клиентами и токенами доступа. Passport предоставляет простой JSON API, который вы можете использовать с любым JavaScript-фреймворком на ваш выбор.

Разумеется, Passport также позволяет легко определить ограничения токенов доступа, которые могут быть запрошены приложением, использующим ваш API:

    Passport::tokensCan([
        'place-orders' => 'Place new orders',
        'check-status' => 'Check order status',
    ]);

Кроме того, в Passport есть вспомогательный посредник для проверки того, что аутентифицированный токеном доступа запрос содержит необходимые ограничения токена:

    Route::get('/orders/{order}/status', function (Order $order) {
        // Токен доступа имеет ограничение "check-status"...
    })->middleware('scope:check-status');

И наконец, Passport поддерживает использование вашего собственного API в вашем JavaScript-приложении, позволяя не беспокоиться о передаче токенов доступа. Это достигается при помощи шифрованных JWT-cookie и синхронизированных CSRF-токенов, позволяя вам сконцентрироваться на том, что важно, — вашем приложении. Подробнее о Passport читайте в [полной документации](/docs/5.3/passport).

### Поиск (Laravel Scout)

Laravel Scout предоставляет простое решение на основе драйверов для добавления полнотекстового поиска в ваши [Eloquent-модели](/docs/5.3/eloquent). С помощью наблюдателей за моделями Scout будет автоматически синхронизировать ваши поисковые индексы с вашими записями Eloquent. Сейчас Scout поставляется с драйвером [Algolia](https://www.algolia.com/); однако, создавать свои драйверы просто, и вы можете дополнить Scout своей собственной реализацией поиска.

Делать модели доступными для поиска так же просто, как добавить трейт `Searchable` в модель:

    <?php

    namespace App;

    use Laravel\Scout\Searchable;
    use Illuminate\Database\Eloquent\Model;

    class Post extends Model
    {
        use Searchable;
    }

Когда трейт добавлен в вашу модель, её информация будет синхронизироваться с вашими поисковыми индексами при сохранении модели:

    $order = new Order;

    // ...

    $order->save();

Когда ваши модели проиндексированы, можно легко выполнять полнотекстовый поиск по всем вашим моделям. Вы можете даже сделать страничный вывод для результатов поиска:

    return Order::search('Star Trek')->get();

    return Order::search('Star Trek')->where('user_id', 1)->paginate();

Разумеется, Scout имеет многие другие возможности, описанные в [полной документации](/docs/5.3/scout).

### Почтовые объекты

> {video} На Laracasts есть бесплатный [видео-урок](https://laracasts.com/series/whats-new-in-laravel-5-3/episodes/6) по этой теме.

Laravel 5.3 поддерживает почтовые объекты. Эти объекты позволяют вам представлять ваши email-сообщения в виде простых объектов вместо того, чтобы настраивать письма в замыканиях. Например, вы можете определить простой почтовый объект для письма "welcome":

    class WelcomeMessage extends Mailable
    {
        use Queueable, SerializesModels;

        /**
         * Создать сообщение.
         *
         * @return $this
         */
        public function build()
        {
            return $this->view('emails.welcome');
        }
    }

После определения почтового объекта вы можете отправить его пользователю с помощью простого и выразительного API. Почтовые объекты позволяют легко определить цель сообщения при просмотре вашего кода:

    Mail::to($user)->send(new WelcomeMessage);

Само собой, вы можете пометить почтовый объект как объект "для очереди", тогда он будет отправлен в фоновом режиме вашими обработчиками очереди:

    class WelcomeMessage extends Mailable implements ShouldQueue
    {
        //
    }

Подробнее о почтовых объектах читайте в [документации по mail](/docs/5.3/mail).

### Хранение загруженных файлов

> {video} На Laracasts есть бесплатный [видео-урок](https://laracasts.com/series/whats-new-in-laravel-5-3/episodes/12) по этой теме.

Один из самых распространённых сценариев хранения файлов в веб-приложениях — хранение файлов, загружаемых пользователем, таких как изображение для профиля, фотографии и документы. Laravel 5.3 позволяет очень просто сохранять загружаемые файлы с помощью нового метода `store` на экземпляре загруженного файла. Просто вызовите метод `store` указав путь для сохранения загруженного файла:

    /**
     * Изменить аватар пользователя.
     *
     * @param  Request  $request
     * @return Response
     */
    public function update(Request $request)
    {
        $path = $request->file('avatar')->store('avatars', 's3');

        return $path;
    }

Подробнее о хранении загруженных файлов читайте в [полной документации](/docs/{{version}}/filesystem#file-uploads).

### Webpack и Laravel Elixir

Вместе с Laravel 5.3 вышла версия Laravel Elixir 6.0 с встроенной поддержкой для сборщиков модулей Webpack и Rollup JavaScript. Теперь файл `gulpfile.js` в Laravel 5.3 по умолчанию использует Webpack для компилирования вашего JavaScript. В [полной документации по Laravel Elixir](/docs/5.3/elixir) содержится подробная информация об обоих этих сборщиках:

    elixir(mix => {
        mix.sass('app.scss')
           .webpack('app.js');
    });

### Структура фронтенда

> {video} На Laracasts есть бесплатный [видео-урок](https://laracasts.com/series/whats-new-in-laravel-5-3/episodes/4) по этой теме.

В Laravel 5.3 более современная структура фронтенда. Это повлияло главным образом на заготовку аутентификации `make:auth` Вместо загрузки ресурсов фронтенда из CDN зависимости указаны в стандартном файле `package.json`.

Кроме того, теперь сразу поддерживаются однофайловые [Vue-компоненты](https://vuejs.org). Пример компонента `Example.vue` находится в директории `resources/assets/js/components`. Более того, новый файл `resources/assets/js/app.js` загружает и настраивает ваши JavaScript-библиотеки и при необходимости Vue-компоненты.

Эта структура обеспечивает лучшую основу для начала разработки современных, надёжных JavaScript-приложений, не требуя от вашего приложения использования какого-либо из этих JavaScript и CSS фреймворка. Подробнее о том, как начать разработку современного фронтенда на Laravel, читайте в новом [вводном разделе о фронтенде](/docs/5.3/frontend).

### Файлы роутов

По умолчанию свежее приложение Laravel 5.3 содержит два файла HTTP-роутов в новой директории верхнего уровня `routes`. Файлы роутов `web` и `api` обеспечивают более явное понимание того, как разделяются роуты для вашего веб-интерфейса и вашего API. `RouteServiceProvider` автоматически назначает префикс `api` роутам из файла `api`.

### Консольные команды замыкания

В добавление к тому, что Artisan-команды определены как классы, теперь они могут быть определены как простые замыкания в методе `commands` вашего файла `app/Console/Kernel.php`. В свежих приложениях Laravel 5.3 метод `commands` загружает файл `routes/console.php`, который позволяет вам определять ваши консольные команды как "роутоподобные" точки входа в ваше приложение на основе замыканий:

    Artisan::command('build {project}', function ($project) {
        $this->info('Building project...');
    });

Подробнее о командах замыканиях читайте в [полной документации по Artisan](/docs/5.3/artisan#closure-commands).

### Переменная `$loop`

> {video} На Laracasts есть бесплатный [видео-урок](https://laracasts.com/series/whats-new-in-laravel-5-3/episodes/7) по этой теме.

В циклах внутри Blade-шаблонов будет доступна переменная `$loop`. Эта переменная предоставляет доступ к некоторым полезным данным, таким как текущий индекс цикла, и является ли данная итерация цикла первой или последней:

    @foreach ($users as $user)
        @if ($loop->first)
            Это первая итерация.
        @endif

        @if ($loop->last)
            Это последняя итерация.
        @endif

        <p>Это пользователь {{ $user->id }}</p>
    @endforeach

Подробнее читайте в [полной документации Blade](/docs/5.3/blade#the-loop-variable).

<a name="laravel-5.2"></a>
## Laravel 5.2

В Laravel 5.2 вошли такие улучшения, как поддержка нескольких драйверов аутентификации, неявная привязка модели, упрощение глобальных заготовок Eloquent, оптимизация создания заготовок для аутентификации, группы посредников, посредник для ограничения скорости, улучшения проверки ввода массивов, и много другое.

### Драйверы аутентификации / "Multi-Auth"

В предыдущих версиях Laravel изначально поддерживался только один драйвер аутентификации — драйвер на основе сессий. В вашем приложении мог быть только один экземпляр аутентифицируемой модели.

В Laravel 5.2 вы можете определить дополнительные драйверы аутентификации, а также определить несколько аутентифицируемых моделей или таблиц пользователей, и контролировать процесс их аутентификации отдельно друг от друга. Например, если у вас есть одна таблица для администраторов и другая таблица для обучаемых, вы можете использовать методы `Auth` для каждой их них отдельно.

### Создание модулей аутентификации

Аутентификация в Laravel и без того довольно проста в настройке, но в Laravel 5.2 появился удобный и быстрый способ создания заготовок для шаблонов аутентификации для вашего «бэкенда». Просто выполните команду `make:auth` в терминале:

    php artisan make:auth

Эта команда сгенерирует совместимые с начальной загрузкой пустые шаблоны для входа пользователя, регистрации и сброса пароля. Также эта команда дополнит ваш файл роутов соответствующими роутами.

> {note} Эта возможность предназначена только для новых приложений, и не подходит для обновления приложений.

### Неявная привязка модели

Явная привязка модели затрудняет внедрение соответствующих моделей непосредственно в ваши роуты и контроллеры. Например, предположим у вас есть роут, определённый следующим образом:

    use App\User;

    Route::get('/user/{user}', function (User $user) {
        return $user;
    });

В Laravel 5.1 вам бы пришлось использовать метод `Route::model`, чтобы указать Laravel, что надо внедрить экземпляр `App\User`, соответствующий параметру `{user}` в определении вашего роута. А в Laravel 5.2 фреймворк **автоматически** внедрит эту модель на основе сегмента URI, позволяя вам быстро получить доступ к нужным экземплярам модели.

Laravel автоматически внедрит модель, если сегмент параметра роута (`{user}`) совпадает с замыканием роута или именем соответствующей переменной метода контроллера (`$user`), и переменная указывает тип класса модели Eloquent.

### Группы посредников

Группы посредников позволяют вам объединять несколько посредников роутов одним удобным ключом и назначать на роут сразу несколько посредников. Например, это может пригодится при создании веб-интерфейса и API в одном приложении. Вы можете сгруппировать роуты сессии и CSRF в группу `web`, , а ограничитель скорости в группу `api`.

На самом деле по умолчанию структура приложения в Laravel 5.2 использует именно такой подход. Например, в стандартном файле`App\Http\Kernel.php` вы найдёте вот что:

    /**
     * Группы посредников роутов приложения.
     *
     * @var array
     */
    protected $middlewareGroups = [
        'web' => [
            \App\Http\Middleware\EncryptCookies::class,
            \Illuminate\Cookie\Middleware\AddQueuedCookiesToResponse::class,
            \Illuminate\Session\Middleware\StartSession::class,
            \Illuminate\View\Middleware\ShareErrorsFromSession::class,
            \App\Http\Middleware\VerifyCsrfToken::class,
        ],

        'api' => [
            'throttle:60,1',
        ],
    ];

Теперь группа `web` может быть назначена на роут следующим образом:

    Route::group(['middleware' => ['web']], function () {
        //
    });

Но не забывайте, что группа посредников `web` *уже* применяется к вашим роутам по умолчанию, так как `RouteServiceProvider` включает её в группу посредников по умолчанию.

### Ограничение скорости

Теперь во фреймворк включён новый посредник ограничения скорости, позволяющий вам легко ограничить количество запросов, которое может выполнить указанный IP за определённое число минут. Например, для ограничения количества запросов от одного IP-адреса до 60 в минуту сделайте так:

    Route::get('/api/users', ['middleware' => 'throttle:60,1', function () {
        //
    }]);

### Проверка ввода массивов

В Laravel 5.2 стало намного проще проверять ввод массивов через поля форм. Например, для проверки того, что каждый e-mail в данном поле ввода массива уникален, сделайте так:

    $validator = Validator::make($request->all(), [
        'person.*.email' => 'email|unique:users'
    ]);

Более того, вы можете использовать символ `*` при написании сообщений для проверки ввода в ваших языковых файлах, что позволяет использовать одно сообщение для полей ввода массивов:

    'custom' => [
        'person.*.email' => [
            'unique' => 'Каждый человек должен иметь уникальный e-mail',
        ]
    ],

### Правило проверки ввода Bail

Добавлено новое правило проверки ввода `bail` , оно останавливает валидатор после первой неудачной проверки по данному правилу. Например, вы можете отменить проверку значения на уникальность `unique`, если оно не прошло проверку на `integer`:

    $this->validate($request, [
        'user_id' => 'bail|integer|unique:users'
    ]);

### Улучшения глобальных заготовок Eloquent

В предыдущих версиях Laravel глобальные заготовки Eloquent были сложными и приводили к появлению ошибок. Но в Laravel 5.2 глобальные заготовки запросов требуют от вас реализации только одного простого метода `apply`.

Подробнее о написании глобальных заготовок читайте в полной [документации по Eloquent](/docs/{{version}}/eloquent#global-scopes).

<a name="laravel-5.1.11"></a>
## Laravel 5.1.11

В Laravel 5.1.11 добавлена поддержка [авторизации](/docs/{{version}}/authorization) в исходном состоянии. Удобно организуйте логику авторизации ваше приложения при помощи простых обратных вызовов или классов политик, и авторизуйте действия при помощи простых и выразительных методов.

Подробнее читайте в [документации по авторизации](/docs/{{version}}/authorization).

<a name="laravel-5.1.4"></a>
## Laravel 5.1.4

В Laravel 5.1.4 добавлена простая блокировка входа в приложение. Подробнее читайте в [документации по аутентификации](/docs/{{version}}/authentication#authentication-throttling) for more information.

<a name="laravel-5.1"></a>
## Laravel 5.1

В Laravel 5.1 продолжены сделанные в Laravel 5.0 улучшения по применению стандарта PSR-2, и добавлено вещание событий, параметры посредников, улучшения Artisan, и многое другое.

### PHP 5.5.9+

Поскольку PHP 5.4 вступит в "завершающий этап жизненного цикла" в сентябре, и для него больше не будет обновлений безопасности от команды разработки PHP, Laravel 5.1 требует PHP 5.5.9 или выше. PHP 5.5.9 обеспечивает совместимость с последними версиями популярных PHP-библиотек, таких как Guzzle и AWS SDK.

### LTS

Laravel 5.1 — первый выпуск Laravel с **долгосрочной поддержкой**. Для Laravel 5.1 будет обеспечено исправление ошибок в течение 2 лет и исправление ошибок безопасности в течение 3 лет. Это наибольший срок поддержки для вышедших версий Laravel, он обеспечивает стабильность и уверенность для больших, корпоративных клиентов и заказчиков.

### PSR-2

[Руководство по стилю программирования PSR-2](https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-2-coding-style-guide.md) принято стандартом для стиля разработки фреймворка Laravel. Вдобавок, все генераторы обновлены для генерирования PSR-2-совместимого синтаксиса.

### Документация

Каждая страница документации Laravel тщательно отредактирована и значительно исправлена. Все примеры кода также пересмотрены и расширены для обеспечения большей релевантности и понимания контекста.

### Вещание событий

Во многих современных веб-приложениях используются веб-сокеты для реализации живых интерфейсов пользователя, работающих в реальном времени. Когда на сервере обновляются какие-либо данные, по веб-сокет соединению отправляется сообщение для обработки клиентом.

Чтобы помочь вам в создании приложений такого типа, Laravel позволяет легко "транслировать" ваши события по веб-сокет соединению. Вещание ваших событий Laravel позволяет вам использовать одинаковые названия событий в вашем коде на стороне сервера и вашем JavaScript-фреймворке на стороне клиента.

Подробнее о вещании событий читайте в [документации по событиям](/docs/{{version}}/events#broadcasting-events).

### Параметры посредников

Теперь посредники могут принимать дополнительные параметры. Например, если в вашем приложении необходима проверка наличия у пользователя необходимой "роли" для выполнения данного действия, вы можете создать посредника `RoleMiddleware`, который принимает название роли в качестве дополнительного аргумента:

    <?php

    namespace App\Http\Middleware;

    use Closure;

    class RoleMiddleware
    {
        /**
         * Запуск фильтра запроса.
         *
         * @param  \Illuminate\Http\Request  $request
         * @param  \Closure  $next
         * @param  string  $role
         * @return mixed
         */
        public function handle($request, Closure $next, $role)
        {
            if (! $request->user()->hasRole($role)) {
                // Переадресация...
            }

            return $next($request);
        }

    }

Параметры посредника можно указать при определении роута, разделив название посредника и его параметры двоеточием `:`. Несколько параметров разделяются между собой запятыми:

    Route::put('post/{id}', ['middleware' => 'role:editor', function ($id) {
        //
    }]);

Подробнее о посредниках читайте в [документации посредников](/docs/{{version}}/middleware).

### Пересмотр тестирования

Встроенные в Laravel возможности для тестирования были значительно улучшены. Набор новых методов обеспечивает гибкий и выразительный интерфейс для взаимодействия с вашим приложением и проверки его откликов. Например, взгляните на следующий тест:

    public function testNewUserRegistration()
    {
        $this->visit('/register')
             ->type('Taylor', 'name')
             ->check('terms')
             ->press('Register')
             ->seePageIs('/dashboard');
    }

Подробнее о тестировании читайте в [документации по тестированию](/docs/{{version}}/testing).

### Фабрики моделей

Теперь Laravel содержит простой способ для создания заглушек Eloquent-моделей при помощи [фабрик моделей](/docs/{{version}}/database-testing#writing-factories). Фабрики моделей позволяют вам легко задать набор «стандартных» атрибутов для вашей Eloquent-модели, и затем сгенерировать экземпляры тестовой модели для ваших тестов и тестовые данные для БД. Также фабрики моделей содержат полезные возможности мощной PHP-библиотеки [Faker](https://github.com/fzaninotto/Faker) для генерирования случайных данных:

    $factory->define(App\User::class, function ($faker) {
        return [
            'name' => $faker->name,
            'email' => $faker->email,
            'password' => str_random(10),
            'remember_token' => str_random(10),
        ];
    });

Подробнее о фабриках моделей читайте в [документации](/docs/{{version}}/database-testing#writing-factories).

### Улучшения Artisan

Теперь Artisan-команды можно определить с помощью простой, роуто-подобной "сигнатуры", которая обеспечивает чрезвычайно простой интерфейс для определения аргументов и параметров командной строки. Например, вы можете определить простую команду и её параметры таким образом:

    /**
     * Имя и сигнатура терминальной команды.
     *
     * @var string
     */
    protected $signature = 'email:send {user} {--force}';

Подробнее об определении Artisan-команд читайте в [документации Artisan](/docs/{{version}}/artisan).

### Структура папок

Для большего соответствия своему назначению папка `app/Commands` переименована в `app/Jobs`. Также директория `app/Handlers`  собрана в единую директорию `app/Listeners`, которая содержит слушатели событий. Однако, эти изменения не обязательны, и вам не требуется обновлять структуру папок для использования Laravel 5.1.

### Шифрование

В предыдущих версиях Laravel за шифрование отвечало PHP-расширение `mcrypt`. А теперь, начиная с Laravel 5.1, за шифрование отвечает расширение `openssl`, которое развивается намного активнее.

<a name="laravel-5.0"></a>
## Laravel 5.0

В Laravel 5.0 введена новая структура приложения для проекта Laravel по умолчанию. Эта новая структура служит лучшей основой для построения надёжных приложений на Laravel, а также обеспечивает поддержку стандартов автозагрузки (PSR-4) для всего приложения. Для начала давайте рассмотрим некоторые основные новшества:

### Новая структура папок

Старая директория `app/models` была полностью удалена. Вместо этого весь ваш код теперь располагается прямо в папке `app` и по умолчанию попадает в пространство имён `App`. Это пространство имён по умолчанию можно быстро изменить с помощью новой Artisan-команды `app:name`.

Контроллеры, посредники и запросы (новый тип классов в Laravel 5.0) теперь сгруппированы в папке `app/Http`, так как все они связаны с транспортным уровнем HTTP вашего приложения. Вместо единого, длинного файла фильтров роутов теперь все посредники разбиты по своим отдельным файлам классов.

Новая директория `app/Providers` заменяет файлы `app/start` из предыдущей версии Laravel 4.x. Эти сервис-провайдеры предоставляют различные функции начальной загрузки для вашего приложения, такие как обработка ошибок, ведение журналов, загрузка роутов и т.д. Само собой, вы можете создавать дополнительные сервис-провайдеры для своего приложения.

Языковые файлы приложения и шаблоны переместились в директорию `resources`.

### Контракты

Все основные компоненты Laravel реализуют интерфейсы, расположенные в репозитории `illuminate/contracts`. У репозитория нет внешних зависимостей. Наличие удобного, централизованного набора интерфейсов, который вы можете использовать для отвязки и внедрения зависимостей, может служить простой альтернативой для фасадов Laravel.

Подробнее о контрактах читайте в [полной документации](/docs/{{version}}/contracts).

### Кэширование роутов

Если ваше приложение полностью состоит из роутов контроллеров, вы можете использовать новую Artisan-команду `route:cache` для радикального ускорения регистрации ваших роутов. Это особенно полезно для приложений с числом роутов 100+. Эта часть вашего приложения получит **радикальное** ускорение.

### Посредники роутов

Вдобавок к "фильтрам" роутов из Laravel 4 теперь в версии 5 поддерживаются HTTP-посредники, а встроенная авторизация и CSRF-"фильтры" преобразованы в посредников. Посредники предоставляют единый, цельный интерфейс для замены всех типов фильтров, позволяя вам легко проверять, и даже отклонять запросы до того, как они попадут в ваше приложение.

Подробнее о посредниках читайте в [документации](/docs/{{version}}/middleware).

### Внедрение методов контроллера

Вдобавок к существующему внедрению конструктора теперь вы можете указывать типы зависимостей в методах контроллера. [Сервс-контейнер](/docs/{{version}}/container) автоматически внедрит зависимости, даже если роут содержит другие параметры:

    public function createPost(Request $request, PostRepository $posts)
    {
        //
    }

### Преднастроенная авторизация

Контроллеры регистрации, авторизации и сброса паролей пользователей теперь встроены сразу из коробки, а также соответствующие им простые шаблоны, расположенные в `resources/views/auth`. Вдобавок миграция таблицы "users" была включена во фреймворк. Наличие этих простых ресурсов позволяет ускорить разработку идей для приложения, не увязая в создании шаблонной авторизации. Шаблоны авторизации доступны по роутам `auth/login` и `auth/register`. Сервис `App\Services\Auth\Registrar` отвечает за проверку данных и создание пользователей.

### Объекты событий

Теперь вы можете определять события как объекты вместо простого использования строк. Например, взгляните на такое событие:

    <?php

    class PodcastWasPurchased
    {
        public $podcast;

        public function __construct(Podcast $podcast)
        {
            $this->podcast = $podcast;
        }
    }

Событие может быть отправлено как обычно:

    Event::fire(new PodcastWasPurchased($podcast));

Само собой, ваш обработчик событий получит объект события вместо списка данных:

    <?php

    class ReportPodcastPurchase
    {
        public function handle(PodcastWasPurchased $event)
        {
            //
        }
    }

Подробнее о работе с событиями читайте в [полной документации](/docs/{{version}}/events).

### Команды / Очереди

Вдобавок к поддерживаемому в Laravel 4 формату очередей команд в Laravel 5 можно представлять ваши задачи для очереди как простые объекты команд. Эти команды живут в директории `app/Commands`. Вот пример команды:

    <?php

    class PurchasePodcast extends Command implements SelfHandling, ShouldBeQueued
    {
        use SerializesModels;

        protected $user, $podcast;

        /**
         * Создание нового экземпляра команды.
         *
         * @return void
         */
        public function __construct(User $user, Podcast $podcast)
        {
            $this->user = $user;
            $this->podcast = $podcast;
        }

        /**
         * Выполнение команды.
         *
         * @return void
         */
        public function handle()
        {
            // Обработка логики покупки подкаста...

            event(new PodcastWasPurchased($this->user, $this->podcast));
        }
    }

Базовый контроллер Laravel использует новый трейт `DispatchesCommands`, позволяя вам легко отправлять ваши команды на выполнение:

    $this->dispatch(new PurchasePodcastCommand($user, $podcast));

Конечно, вы можете использовать команды также и для команд, выполняющихся синхронно (не в очереди). На самом деле, использование команд — отличный способ инкапсулировать сложные задачи, которые необходимо выполнять вашему приложению. Более подробно об этом написано в документации по [командной шине](/docs/5.0/bus).

### Очередь БД

Драйвер очереди `database` теперь включён в Laravel — это простой, локальный драйвер очереди, не требующий установки дополнительных пакетов кроме ПО вашей БД.

### Планировщик Laravel

Раньше разработчикам приходилось создавать Cron-задачи для каждой консольной команды, которую они хотели запланировать. Это утомительно. Для планирования консольных команд теперь не ведётся контроль версий, и для добавления Cron-задач вам необходимо подключаться к серверу по SSH. Давайте упростим нам жизнь. Планировщик команд Laravel позволяет вам гибко и выразительно задавать план команд в самом Laravel, а на сервере нужна только одна Cron-задача.

Это выглядит так:

    $schedule->command('artisan:command')->dailyAt('15:00');

Чтобы узнать всё о планировщике, загляните в [полную документацию](/docs/{{version}}/scheduling).

### Tinker / Psysh

Теперь команда `php artisan tinker` использует  [Psysh](https://github.com/bobthecow/psysh) от Джастина Хильмана, более надёжный REPL для PHP. Если вам нравился Boris в Laravel 4, то вы полюбите Psysh. И более того — он работает в Windows! Для начала просто попробуйте:

    php artisan tinker

### DotEnv

Вместо множества сбивающих с толку, вложенных папок с настройками среды, Laravel 5 теперь использует[DotEnv](https://github.com/vlucas/phpdotenv) от Ванса Лукаса. Эта библиотека предоставляет простой способ управления вашими настройками сред, и делает простым определение среды в Laravel 5.Подробнее читайте в [документации по настройке](/docs/{{version}}/installation#environment-configuration).

### Laravel Elixir

Laravel Elixir от Джеффри Вэя предоставляет гибкий, выразительный интерфейс для компилирования и соединения ваших ресурсов. Если вы имели печальный опыт изучения Grunt или Gulp, то эти страшные времена позади. Elixir помогает начать пользоваться Gulp для компилирования ваших Less, Sass и CoffeeScript. Он может даже запустить ваши тесты для вас!

Подробнее об Elixir читайте в [полной документации](/docs/5.3/elixir).

### Laravel Socialite

Laravel Socialite — необязательный, совместимый с Laravel 5.0+ пакет, обеспечивающий безболезненную авторизацию с помощью провайдеров OAuth. На данный момент Socialite поддерживает работу с Facebook, Twitter, Google и GitHub. Вот как это выглядит:

    public function redirectForAuth()
    {
        return Socialize::with('twitter')->redirect();
    }

    public function getUserFromProvider()
    {
        $user = Socialize::with('twitter')->user();
    }

Больше не надо тратить часы на написание потоков авторизации OAuth. Начните за несколько минут! В [полной документации](/docs/{{version}}/authentication#social-authentication) вы найдете все подробновсти.

### Интеграция Flysystem

Теперь Laravel содержит мощную библиотеку для абстракции файловой системы [Flysystem](https://github.com/thephpleague/flysystem), обеспечивающую безболезненную интеграцию с локальным хранилищем, облачными хранилищами Amazon S3 и Rackspace — всё в одном, едином и элегантном API! Хранить файлы в Amazon S3 теперь вот так просто:

    Storage::put('file.txt', 'contents');

Более подробно об интеграции Laravel Flysystem читайте в [полной документации](/docs/{{version}}/filesystem).

### Запросы форм

В Laravel 5.0 введены **запросы форм**, которые наследуют класс `Illuminate\Foundation\Http\FormRequest`. Эти объекты запросов могут быть совмещены с внедрением методов контроллера для обеспечения метода проверки ввода пользователей, без необходимости написания шаблонного кода. Давайте разберёмся подробнее и взглянем на пример `FormRequest`:

    <?php

    namespace App\Http\Requests;

    class RegisterRequest extends FormRequest
    {
        public function rules()
        {
            return [
                'email' => 'required|email|unique:users',
                'password' => 'required|confirmed|min:8',
            ];
        }

        public function authorize()
        {
            return true;
        }
    }

Когда класс определён, мы можем указать его тип в нашем действии контроллера:

    public function register(RegisterRequest $request)
    {
        var_dump($request->input());
    }

Когда сервис-контейнер Laravel определяет, что внедряемый им класс — это экземпляр `FormRequest`, запрос **автоматически пройдёт проверку**. Это значит, что если вызвано действие вашего контроллера, то вы можете быть уверены, что ввод HTTP-запроса прошёл проверку по тем правилам, которые вы указали в классе запроса формы. Более того, если запрос некорректен, будет автоматически вызвана HTTP-переадресация, которую вы можете настроить, а сообщение об ошибке будет либо передано в сессию, либо преобразовано в JSON. **Проверка форм никогда не была настолько простой.** Подробнее о проверке `FormRequest` читайте в [документации](/docs/{{version}}/validation#form-request-validation).

### Простая проверка запроса контроллера

Базовый контроллер Laravel 5 теперь содержит трейт `ValidatesRequests`. Этот трейт предоставляет простой метод `validate` для проверки входящих запросов. Если `FormRequests` для вашего приложения избыточен, попробуйте это:

    public function createPost(Request $request)
    {
        $this->validate($request, [
            'title' => 'required|max:255',
            'body' => 'required',
        ]);
    }

Если проверка неудачна, будет выброшено исключение, и нужный HTTP-отклик будет автоматически возвращён в браузер. Ошибки при проверки будут переданы даже в сессию! Если запрос был AJAX-запросом, то Laravel даже позаботиться об отправке JSON-шаблона ошибок проверки обратно к вам.

Подробнее об этом новом методе читайте в [документации](/docs/{{version}}/validation#validation-quickstart).

### Новые генераторы

В дополнение к новой структуре приложения по умолчанию в фреймворк были добавлены новые Artisan-команды генераторы. Для подробностей посмотрите `php artisan list`.

### Кэш настроек

Теперь вы можете кэшировать все свои настройки в едином файле с помощью команды `config:cache`.

### Symfony VarDumper

Популярная вспомогательная функция `dd`, которая сохраняет переменную отладочную информацию, была переведена на использование восхитительного Symfony VarDumper. Это обеспечивает цветовое выделение вывода и даже сворачивание массивов. Просто попробуйте сделать так в своём проекте:

    dd([1, 2, 3]);

<a name="laravel-4.2"></a>
## Laravel 4.2

Полный список изменений этой версии можно увидеть, выполнив команду `php artisan changes` в установленной версии 4.2 или [посмотрев файл изменений на GitHub](https://github.com/laravel/framework/blob/4.2/src/Illuminate/Foundation/changes.json). В это описание вошли только значительные улучшения и изменения данной версии.

> {note} Во время разработки версии 4.2 многие небольшие исправления и улучшения были включены в различные подверсии Laravel 4.1. Поэтому не забудьте также ознакомиться со списком изменений Laravel 4.1!

### Требование PHP 5.4

Laravel 4.2 требует PHP 5.4 или выше. Это обновлённое требование PHP позволяет нам использовать новые возможности PHP, такие как трейты, чтобы обеспечивать более выразительные интерфейсы для таких инструментов как [Laravel Cashier](/docs/billing). Также PHP 5.4 даёт преимущество в скорости и производительности по сравнению с PHP 5.3.

### Laravel Forge

Laravel Forge— новое веб-приложение для простого создания и управления
PHP-серверами в облаке по вашему выбору, включая Linode, DigitalOcean, Rackspace и Amazon EC2. Поддерживая автоматическую настройку Nginx, доступ по ключам SSH, автоматизацию работы Cron, мониторинг серверов через NewRelic & Papertrail, "Push To Deploy" ("нажми, чтобы развернуть"), настройку обработчика очереди Laravel, и многое другое, Forge предоставляет наиболее простой и доступный способ для запуска всех ваших приложений Laravel..

Сейчас установочный файл конфигурации Laravel 4.2 `app/config/database.php` по умолчанию настроен на использование Forge, что обеспечивает более удобное развёртывание свежих приложений на платформе.

Больше информации о Laravel Forge можно найти на [официальном сайте Forge](https://forge.laravel.com).

### Laravel Homestead

Laravel Homestead — официальное окружение Vagrant для разработки надёжных приложений на Laravel и PHP. Подавляющее большинство необходимых для коробок операций обрабатывается перед тем, как коробка подготавливается к распространению, что позволяет ей загружаться чрезвычайно быстро. Homestead включает в себя Nginx 1.6, PHP 5.5.12, MySQL, Postgres, Redis, Memcached, Beanstalk, Node, Gulp, Grunt и Bower. Homestead содержит простой конфиг`Homestead.yaml` для управления несколькими приложениями Laravel в одной коробке.

Сейчас по умолчанию установленный Laravel 4.2 содержит конфиг-файл `app/config/local/database.php`, который настроен на использование базы данных Homestead, что делает начальную установку и настройку Laravel удобнее.

В официальную документацию также была включена [документация Homestead](/docs/homestead).

### Laravel Cashier

Laravel Cashier — простая, удобная библиотека для управления подписками биллинга с помощью Stripe. Начиная с версии Laravel 4.2, мы добавили документацию по Cashier к основной документации Laravel, хотя установка самого компонента по-прежнему не обязательна. Эта версия Cashier содержит много исправлений, поддерживает множество валют и совместима с последним Stripe API.

### Обработчики очереди — демоны

Команда Artisan `queue:work` теперь поддерживает параметр `--daemon` для запуска обработчика в "режиме демона", это значит, что обработчик будет продолжать выполнять работу без перезагрузки фреймворка. Это приводит к значительному снижению загрузки процессора за счёт несколько более сложного процесса развёртывания приложения.

Больше информации о демонах — обработчиках очереди можно найти в [документации по очередям](/docs/queues#daemon-queue-worker).

### Драйверы Mail API

В Laravel 4.2 вошли новые драйверы Mailgun и Mandrill API для функций `Mail`. Для многих приложений это обеспечивает более быстрый и надёжный способ отправки электронной почты, чем варианты SMTP. Новые драйверы используют HTTP библиотеку Guzzle 4.

### Мягко удаляемые трейты

Более чистая архитектура для "мягких удалений" и других "глобальных областей" была добавлена в PHP 5.4 с помощью трейтов. Эта новая архитектура позволяет проще создавать подобные глобальные трейты и чище разделять задачи внутри самого фреймворка.

Больше информации о новых `SoftDeletingTrait` можно найти в [документации Eloquent](/docs/eloquent#soft-deleting).

### Удобная аутентификация и запоминаемые трейты

Теперь Laravel 4.2 по-умолчанию использует простые трейты, содержащие необходимые свойства для пользовательских интерфейсов аутентификации и напоминания паролей. Это обеспечивает более чистый файл модели `User` по умолчанию.

### "Simple Paginate"

В построитель запросов и Eloquent был добавлен новый метод `simplePaginate` (простое разбиение на страницы), который обеспечивает более эффективные запросы при использовании простых ссылок "Далее" и "Назад" в вашем постраничном представлении.

### Подтверждение миграций

Теперь в работающих приложениях деструктивные операции миграций будут запрашивать подтверждение. Команды можно выполнять без дополнительных подтверждений, используя параметр `--force`.

<a name="laravel-4.1"></a>
## Laravel 4.1

### Полный список изменений

Полный список изменений для этой версии можно увидеть, выполнив команду `php artisan changes` в установленной версии 4.1 или [посмотрев файл изменений на GitHub](https://github.com/laravel/framework/blob/4.1/src/Illuminate/Foundation/changes.json). Это описание содержит только основные улучшения и изменения в релизе.

### Новый компонент SSH

В этот релиз вошёл полностью новый компонент `SSH`. Данная функция позволяет вам легко подключаться через SSH к удалённым серверам и выполнять команды. Чтобы узнать больше, загляните в [документацию компонента SSH](/docs/4.1/ssh).

The new `php artisan tail` command utilizes the new SSH component. For more information, consult the `tail` [command documentation](http://laravel.com/docs/ssh#tailing-remote-logs).

### Boris в Tinker

Теперь команда `php artisan tinker` использует [Boris REPL](https://github.com/d11wtq/boris), если ваша система поддерживает его. Для использования этой возможности должны быть установлены PHP расширения `readline` и `pcntl`. Если у вас нет этих расширений, будет использована оболочка из 4.0.

### Улучшения Eloquent

В Eloquent добавлено новое отношение `hasManyThrough`. Посмотрите, как им пользоваться в [документации Eloquent](/docs/eloquent#has-many-through).

A new `whereHas` method has also been introduced to allow [retrieving models based on relationship constraints](/docs/eloquent#querying-relations).

### Подключения чтения/записи к БД

Теперь автоматическая обработка отдельных подключений чтения/записи доступна во всём слое БД, в том числе в построителе запросов и Eloquent. Чтобы узнать больше, загляните в [эту документацию](/docs/database#read-write-connections).

### Приоритет очереди

Теперь поддерживаются приоритеты очереди с помощью передачи в команду `queue:listen` списка, разделённого запятыми.

### Обработка неудавшихся заданий очереди

Теперь в очередях есть возможность автоматической обработки неудавшихся заданий при использовании нового переключателя `--tries` в `queue:listen`. Больше информации об обработке неудавшихся заданий можно найти в [документации об очередях](/docs/queues#failed-jobs).

### Тэги кэша

"Секции" кэша были заменены "тэгами". Тэги кэша позволяют назначать несколько «тэгов» элементу кэша и получать элементы по тэгу. Больше информации об использовании тэгов кэша можно найти в [документации кэша](/docs/cache#cache-tags).

### Гибкие напоминатели паролей

Движок напоминателя паролей был изменён для обеспечения большей гибкости разработки при проверке паролей, выводе сообщений о состоянии в сессии, и т.д. Чтобы узнать больше об использовании расширенного движка напоминателя паролей, [взгляните на документацию](/docs/4.1/security#password-reminders-and-reset).

### Улучшенный движок роутов

В Laravel 4.1 вошёл полностью переписанный слой роутов. API прежний, но регистрация роутов на все 100% быстрее по сравнению с 4.0. Весь движок был значительно упрощён, и зависимость от Symfony Routing была минимизирована до составления выражений для роутов.

### Улучшенный движок сессий

Также в версию вошёл полностью новый движок сессий. Также как и улучшения роутов, новый слой сессий проще и быстрее. Мы больше не используем средства обработки сессий Symfony(а значит и PHP), а используем своё решение, которое проще и легче в обслуживании.

### Doctrine DBAL

Если вы используете функцию `renameColumn` в ваших миграциях, то вам надо будет добавить зависимость `doctrine/dbal` в ваш файл `composer.json`. Этот пакет больше не входит в Laravel по умолчанию.
