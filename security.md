git 2fbb57348ea941ebac4f9d0bf1225f234385b4ee

---

# Безопасность

- [Конфигурация](#configuration)
- [Хранение паролей](#storing-passwords)
- [Аутентификация пользователей](#authenticating-users)
- [Ручная аутентификация](#manually)
- [Аутенификация в роутах](#protecting-routes)
- [HTTP-аутентификация](#http-basic-authentication)
- [Сброс и напоминание пароля](#password-reminders-and-reset)
- [Шифрование](#encryption)
- [Драйвера аутентификации](#authentication-drivers)

<a name="configuration"></a>
## Конфигурация

Laravel стремится сделать реализацию авторизации максимально простой. Фактически, после установки фреймворка почти всё уже настроено. Настройки хранятся в файле `app/config/auth.php`, который содержит несколько хорошо документированных параметров для настройки поведения методов аутентификации.

"Из коробки" приложение Laravel включает в себя модель `User` в папке `app/models`, которая может использоваться вместе с дефолтным драйвером аутентификации Eloquent. При создании таблицы для данной модели убедитесь, что поле пароля принимает как минимум 60 символов.

Если ваше приложение не использует Eloquent, вы можете использовать драйвер `database`, который использует конструктор запросов Laravel.

> **Примечание:** Перед тем как начать, пожалуйста, убедитесь, что таблица `users` (или другая, в которой хранятся пользователи) содержит столбец `remember_token` (VARCHAR(100)). Этот столбец испольдуется для хранения токена, когда пользователь при логине ставит галку "запомнить меня".

<a name="storing-passwords"></a>
## Хранение паролей

Класс `Hash` содержит методы для безопасного хэширования с помощью Bcrypt.

#### Хэширование пароля по алгоритму Bcrypt:

	$password = Hash::make('secret');

#### Проверка пароля по хэшу:

	if (Hash::check('secret', $hashedPassword))
	{
		// Пароль подходит
	}

#### Проверка на необходимость перехэширования пароля:

	if (Hash::needsRehash($hashed))
	{
		$hashed = Hash::make('secret');
	}

<a name="authenticating-users"></a>
## Аутентификация пользователей

Для аутентификации пользователя в вашем приложении вы можете использовать метод `Auth::attempt`.

	if (Auth::attempt(array('email' => $email, 'password' => $password)))
	{
		return Redirect::intended('dashboard');
	}

Заметьте, что поле `email` не обязательно и оно используется только для примера. Вы должны использовать любое поле, которое соответствует имени пользователя в вашей БД. Метод `Redirect::intended` отправит пользователя на URL, который он пытался просмотреть до того, как запрос был перехвачен фильтром аутентификации. Также в этом методе можно задать дополнительный URL, куда будет осуществлен переход, если первый URL не доступен.

Когда вызывается метод `attempt`, запускается [событие](/docs/events) `auth.attempt`. При успешной авторизации также запускается событие `auth.login`.

Для определения того, авторизован ли пользователь или нет, можно использовать метод `check.

#### Проверка авторизации пользователя

	if (Auth::check())
	{
		// Пользователь уже вошёл в систему
	}

Если вы хотите предоставить функциональность типа "запомнить меня", то вы можете передать `true` вторым параметром к методу `attempt`, который будет поддерживать авторизацию пользователя без ограничения по времени (пока он вручную не выйдет из системы). В такоем случае у вашей таблицы `users` должен быть строковой столбец `remember_token` для хранения токена пользователя.

	if (Auth::attempt(array('email' => $email, 'password' => $password), true))
	{
		// Пользователь был запомнен
	}

**Примечание:** если метод `attempt` вернул `true`, то пользователь успешно вошёл в систему.

#### Имеет ли пользователь токен "запомнить меня"
Метод `viaRemember` позволяет узнать, вошел ли пользователь при помощи фичи "запомнить меня".

	if (Auth::viaRemember())
	{
		// Пользователь вошел, так как ранее ставил галку "запомнить меня"
	}

Вы также можете передать дополнительные условия для запроса к таблице:

#### Авторизация пользователя с использованием условий

    if (Auth::attempt(array('email' => $email, 'password' => $password, 'active' => 1)))
    {
        // Вход, если пользователь активен, не отключен и существует.
    }

> **Примечание** Для повышения безопасности после аутентификации фреймворк регенерирует ID сессии пользователя.

Как только пользователь авторизован вы можете обращаться к модели `User` и её свойствам.

#### Доступ к залогиненному пользователю

	$email = Auth::user()->email;

Для простой аутентификации пользователя по ID используется метод `loginUsingId`:

	Auth::loginUsingId(1);

Метод `validate` позволяет вам проверить данные для входа без осуществления самого входа.

#### Проверка данных для входа без авторизации

	if (Auth::validate($credentials))
	{
		//
	}

Вы также можете использовать метод `once` для авторизации пользователя в системе только для одного запроса. Сессии и cookies не будут использованы.

#### Аутентификация пользователя на один запрос

	if (Auth::once($credentials))
	{
		//
	}

#### Выход пользователя из приложения

	Auth::logout();

<a name="manually"></a>
## Ручная авторизация

Если вам нужно войти существующим пользователем, просто передайте его модель в метод `login`:

	$user = User::find(1);

	Auth::login($user);

Это эквивалентно аутентификации пользователя через его данные методом `attempt`.
