git d4428a9328c65d702bb02e628e5bf91decdb1254

---

# Пагинация

- [Настройка](#configuration)
- [Использование](#usage)
- [Параметры в ссылках](#appending-to-pagination-links)
- [Конвертация в JSON](#converting-to-json)

<a name="configuration"></a>
## Настройка

В других фрейморках пагинация (постраничный вывод данных) может быть большой проблемой. Laravel же делает этот процесс безболезненным. Фреймворк способен сам генерировать HTML пагинации, совместимый с Twitter Bootstrap. 


Шаблон `pagination::slider` выведет "умный" список страниц в зависимости от текущего положения, а шаблон `pagination::simple` просто создаст ссылки "Назад" и "Вперёд" для простой навигации. **Оба шаблона совместимы с [Twitter Bootstrap](http://getbootstrap.com).**

<a name="usage"></a>
## Использование

Есть несколько способов разделения данных на страницы. Самый простой - используя метод `paginate` объекта-[построителя запросов](/queries] или на модели [Eloquent](/eloquent).

#### Постраничный вывод выборки из БД

	$users = DB::table('users')->paginate(15);

> **Примечание:** Если вы используете `groupBy` в запросе, то встроенная пагинация Laravel будет работать неэффективно. В этом случае вам нужно сделать пагинацию вручную при помощи Paginator::make.

#### Постраничный вывод запроса Eloquent

	$users = User::where('votes', '>', 100)->paginate(15);

Аргумент, передаваемый методу `paginate` - число строк, которые вы хотите видеть на одной странице. Блок пагинации в шаблоне отображаются методом `links`:

	<div class="container">
		<?php foreach ($users as $user): ?>
			<?php echo $user->name; ?>
		<?php endforeach; ?>
	</div>

	<?php echo $users->render(); ?>

Это всё, что нужно для создания страничного вывода! Заметьте, что нам не понадобилось уведомлять фреймворк о номере текущей страницы - Laravel определит его сам. Номер страницы добавляется к урлу в виде строки запроса с параметром page: `?page=N`.

Вы можете получить информацию о текущем положении с помощью этих методов:

- `currentPage`
- `lastPage`
- `perPage`
- `total`
- `count`

#### "Упрощённая пагинация"

Если вам нужно выводить только ссылки "Следующая страница" и "Предыдущая страница", то вы можете использовать метод `simplePaginate`. В таком случае запрос в БД будет более простым. Это полезно на очень больших объемах данных и там, где пользователю нужны первые несколько страниц и нет необходимости переходить в самую глубину.

	$someUsers = User::where('votes', '>', 100)->simplePaginate(15);

#### Создание пагинации вручную

Иногда у вас есть массив, и вы хотите вывести его содержимое с пагинацией. Вы сможете это сделать, создав объект `Illuminate\Pagination\Paginator` или `Illuminate\Pagination\LengthAwarePaginator`.

#### Настройка URI для вывода ссылок

	$users = User::paginate();

	$users->setPath('custom/url');

Пример выше создаст ссылки наподобие такой: http://example.com/custom/url?page=2

<a name="appending-to-pagination-links"></a>
## Параметры в ссылках

Вы можете добавить параметры запросов к ссылкам страниц с помощью метода `appends` страничного объекта:

	<?php echo $users->appends(['sort' => 'votes'])->render(); ?>

Код выше создаст ссылки наподобие http://example.com/something?page=2&sort=votes

Чтобы добавить к урлу хэш-последовательность ("#xyz" в конце урла), используйте метод `fragment`:

	<?php echo $users->fragment('foo')->render(); ?>

Код выше создаст ссылки типа http://example.com/something?page=2#foo

<a name="converting-to-json"></a>
## Конвертация To JSON

Класс `Paginator` реализует (implements) `Illuminate\Contracts\Support\JsonableInterface`, следовательно, у него есть метод `toJson`, который используется для вывода пагинируемой информации в формате json. Помимо пагинируемых данных, которые располагаются в `data`, этот метод добавляет мета-информацию, а именно: `total`, `current_page` и `last_page`. 