git 944e62f38234a00cb45c2118e9b5ab7373cc074d

---

# Настройка

- [Вступление](#introduction)
- [Действия после установки](#after-installation)
- [Настройка среды выполнения](#environment-configuration)
- [Защита конфиденциальных данных](#protecting-sensitive-configuration)
- [Режим обслуживания](#maintenance-mode)
- [Красивые URL](#pretty-urls)

<a name="introduction"></a>
## Вступление

Все файлы настроек Laravel хранятся в папке `config`. Опции хорошо документированы в комментариях, так что рекомендуем открыть и изучить эти файлы.

<a name="configuration"></a>
## Действия после установки

### Имя вашего приложения

Первая вещь, которую вы должны сделать после установки фреймворка - придумать имя своему будущему приложению. Это имя будет фигурировать в качестве корневого имени в неймспейсе классов, которые будут использоваться в вашем приложении. По умолчанию ваше приложение находится в папке `app`, имеет имя `App` и автозагружается при помощи Composer согласно [стандарту PSR-4](http://www.php-fig.org/psr/psr-4/). Вы можете изменить его при помощи артизан-команды `app:name`.

Например, чтобы изменить имя приложения на Horsefly, выполните эту команду в корне установленного фреймворка:

	php artisan app:name Horsefly

###  Дальнейшее конфигурирование приложения

Laravel "из коробки" практически не требует дополнительного конфигурирования - вы можете сразу начать писать код. Максимум, вам может быть нужно изменить настройки доступа к базе данных в `config/database.php` и, возможно, изменить параметры `timezone` и `locale` в `config/app.php`.

Далее, вам нужно определиться с названием [среды выполнения](/docs/master/configuration#environment-configuration), в которой будет работать ваше приложение на данной машине. Например, когда вы разрабатываете приложение, вам нужно видеть подробный текст возникающих ошибок. По умолчанию фреймворк считает, что выполняется в среде `production` и в ней текст ошибки не выводится. Поэтому вы определяете, что на данной машине у вас среда выполнения `local` и в `config/local/app.php` ставите параметр `debug` в `true`.

> **Примечание** Никогда не ставьте `app.debug` в `true` в продакшне, т.е. на хостинге. Просто никогда.

### Права на запись

Папки внутри `storage` должны быть доступны веб-серверу для записи. Если вы устанавливаете фреймворк на Linux или MacOs - открыть папки на запись можно командой `chmod -R 777 storage`

### Пути

Расположение некоторых папок, используемых фреймворком, можно изменить. Пути до таких папок задаются в `bootstrap/paths.php`.

<a name="environment-configuration"></a>
## Настройка среды выполнения (the environment)

Часто необходимо иметь разные значения для разных настроек в зависимости от среды, в которой выполняется приложение. Например, вы можете захотеть использовать разные драйвера кэша на локальном и производственном (продакшн) серверах. Это легко достигается использованием настроек, зависящих от среды.

Просто создайте новую папку внутри папки `config`, название которой совпадает с именем вашей среды, таким как `local`. Затем создайте файлы настроек, которые вы хотите переопределить, и укажите в них значения для этой среды. Например, вы можете переопределить драйвер кэша для локальной среды, создав файл `cache.php` внутри `config/local` с таким содержимым:

	<?php

	return [

		'driver' => 'file',

	];

> **Примечание:** Не используйте слово 'testing' для названия среды - оно зарезервировано для юнит-тестов.

Заметьте, что вам не нужно указывать _каждую_ настройку, которая есть в исходном конфигурационном файле, кроме настроек, которые вы хотите переопределить. Настройки среды будут наложены на эти базовые файлы.

Теперь нам нужно сообщить Laravel как определить, в какой среде он работает. Начальная среда всегда `production`. Однако, вы можете настроить и другие среды в файле `bootstrap/environment.php` который находится в корне установки Laravel. В этом файле вы найдёте вызов метода `$app->detectEnvironment`. Функция, которая ему передаётся, используется для определения текущей среды. В этой функции вы можете определять среу выполнения по имени машины, вызываемому домену или переменной окружения.

	<?php

	$env = $app->detectEnvironment(function()
    {
        return getenv('APP_ENV');
    });

В этом примере название среды выполнения у нас находится в переменной окружения APP_ENV. Занести туда значения вы можете в файле `.htaccess`, правилах nginx или при помощи файла `.env`, который должен находиться в корне фреймворка. По поводу файла См. [соответствующий раздел документации](#protecting-sensitive-configuration).

#### Получение текущей среды

Вы можете получить текущую среду с помощью метода `environment` объекта `Application`:

	$environment = $app->environment();

Вы также можете передать аргументы в этот метод чтобы проверить, совпадает ли среда с переданным значением:

	if ($app->environment('local'))
	{
		// Среда - local
	}

	if ($app->environment('local', 'staging'))
	{
		// Среда - local ИЛИ staging
	}

`$app` можно получить из [сервис-контейнера](/docs/master/container) по ключу `'Illuminate\Contracts\Foundation\Application'`. Если вы используете вышеприведенный код в сервис-провайдере, то вместо `$app` используйте `$this->app`.

<a name="provider-configuration"></a>
## Настройка сервис-провайдеров

При использовании среды, вы возможно захотите "добавить" дополнительные [сервис-провайдеры](/docs/master/providers) к исходным в файле `app`. Однако, если вы это сделаете, вы заметите, что сервис-провайдеры среды переопределяют сервис-провайдеры в вашем исходном файле настроек `app`. Чтобы заставить сервис-провайдеры не переопределять, а добавляться к существующим, используйте вспомогательный метод `append_config` в вашем файле настроек среды `app`:

	'providers' => append_config(array(
		'LocalOnlyServiceProvider',
	)) 


<a name="protecting-sensitive-configuration"></a>
## Защита конфиденциальных данных

Для "настоящих" приложений предпочтительно хранить конфиденциальные данные вне ваших обычных файлов настроек. Такие данные как пароли к базам данных, ключи доступа к различным API-сервисам, ключи шифрования должны храниться вне ваших обычных файлов настроек всегда, когда это только возможно. И где же мы должны их хранить в таком случае? К счастью, Laravel предоставляет очень простое решение для защиты таких настроек - хранение их в "dot" файлах (имена этих файлов начинаются с точки).

Во-первых, [настройте ваше приложение](/docs/master/configuration#environment-configuration) таким образом, чтобы ваш компьютер определялся в среде `local`. Далее, создайте файл `.env.php` в корневой папке вашего проекта (в ней обычно находится файл `composer.json`). `.env`-файл содержит список переменных окружения:

	APP_ENV=local
	DB_USERNAME=homestead
	DB_PASSWORD=homestead

Все эти значения будут автоматически доступны в вашем приложении в суперглобальных переменных `$_ENV` и `$_SERVER`. Теперь вы можете обратиться к этим глобальным переменным внутри ваших файлов настроек:

	'password' => $_ENV['DB_PASSWORD']

Убедитесь, что вы добавили файл `.env.php` в ваш файл `.gitignore`. Это позволит другим разработчикам в вашей команде создавать свои собственные локальные файлы настроек, также как и спрятать ваши конфиденциальные данные от системы котроля.

Теперь, на вашем производственном (продакшн) сервере, создайте файл `.env.php` в корне вашего приложения, который будет содержать настройки для этого конкретного сервера. Как и файл локальный `.env.php`, этот файл никогда не должен включаться в систему контроля версий (git, mercurial, svn и т.п.).

> **Примечание:** Вы можете создавать файлы для каждой среды вашего приложения. Например, среда `development` будет всегда загружать файл `.env.development.php`, если он существует. Однако, среда `production` (среда производства) всегда использует файл `.env.php`.

<a name="maintenance-mode"></a>
## Режим обслуживания

Когда ваше приложение находится в режиме обслуживания (maintenance mode), специальный шаблон будет отображаться вместо всех ваших маршрутов. Это позволяет "отключать" ваше приложение во время обновления или обслуживания. Проверка на режим обслуживания уже включена в стандартный фильтр `App::before` в файле `app/Http/Filters/MaintenanceFilter.php`. Ответ от этой проверки будет возвращен пользователю когда приложение находится в режиме обслуживания.

Для включения этого режима просто выполните команду Artisan-а `down`:

	php artisan down

Чтобы выйти из режима обслуживания выполните команду `up`:

	php artisan up

### Режим обслуживания и очереди

Пока ваше приложение находится в режиме обслуживания, [очереди](/docs/master/queues) не будут обрабатываться. Работа очередей будет возобновлена когда приложение выйдет из режима обслуживания.

<a name="pretty-urls"></a>
## Красивые URL

### Apache

Laravel поставляется вместе с файлом `public/.htaccess`, который настроен для обработки URL без указания `index.php`. Если вы используете Apache в качестве веб-сервера обязательно включите модуль `mod_rewrite`.

Если стандартный `.htaccess` не работает для вашего Apache, попробуйте следующий:

	Options +FollowSymLinks
	RewriteEngine On

	RewriteCond %{REQUEST_FILENAME} !-d
	RewriteCond %{REQUEST_FILENAME} !-f
	RewriteRule ^ index.php [L]

### Nginx

Если вы используете в качествет веб-сервера Nginx, то используйте для ЧПУ следующую конструкцию:

	location / {
		try_files $uri $uri/ /index.php?$query_string;
	}

Если вы используете [Homestead](/docs/master/homestead), то вам ничего делать не нужно, там всё это уже настроено.
