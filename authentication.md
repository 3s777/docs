git 9b9b6aa5e51bbcdffdd92c5be4bef3b15652821c

---

# Аутентификация

- [Введение](#introduction)
- [Аутентификация пользователей](#authenticating-users)
- [Получение аутентифицированного пользователя](#retrieving-the-authenticated-user)
- [Ограничение доступа к роутам в приложении](#protecting-routes)
- [Аутентификация на основе HTTP Basic](#http-basic-authentication)
- [Напоминание и сброс пароля](#password-reminders-and-reset)
- [Аутентификация через социальные сети](#social-authentication)

<a name="introduction"></a>
## Введение

Laravel позволяет сделать аутентификацию очень простой. Фактически, почти всё уже готово к использованию «из коробки».
Настройки аутентификации находятся в файле `config/auth.php`, который содержит несколько хорошо документированных опций для настройки
механизма аутентификации.

По умолчанию, Laravel использует модель `App\User` в каталоге `app`. Эта модель может использоваться вместе с драйвером аутентификации на базе Eloquent.

При создании схемы таблицы для этой модели не забудьте, что длина поля с паролем должна быть минимум в 60 символов.

Если ваше приложение не использует Eloquent, вы сожете использовать драйвер аутентификации `database`, который работает через построитель запросов.

<a name="authenticating-users"></a>
## Аутентификация пользователей

В Laravel уже есть два контроллера, относящихся к механизму аутентификации. Контроллер `AuthController` обрабатывает регистрацию
пользователей и вход в приложение (logging in), тогда как контроллер `PasswordController` сожержит механизмы для сброса забытых паролей
у существующих пользователей.

Каждый из этих контроллеров использует трейты для поключения необходимых методов. Как правило, вам не нужно менять код этих контроллеров.
Шаблоны, используемые этими контроллерами, находятся в каталоге `resources/views/auth`, вы можете свободно изменять их так, как вам нужно.

### Регистрация пользователей

Для редактирования набора полей формы, которую заполняет пользователь при регистрации, необходимо изменить класс `App\Services\Registrar`,
который так же отвечает за валидацию введённых данных и создание новых пользователей. 

Метод `validator` класса `Registrar` содержит правила валидации для новых пользователей, тогда как метод `create` отвечает непосредственно
за создание новой записи о пользователе в БД вашего приложения. Вы можете изменять код этих методов при необходимости.
Сервис `Registrar` вызывается в контроллере `AuthController` через метод, находящийся в трейте `AuthenticatesAndRegistersUsers`.

#### Ручная аутентификация

Если вы не хотите использовать механизм, предоставляемый контроллером `AuthController`, то вы должны использовать сервис аутентификации напрямую.
Для начала давайте посмотрим на метод `attempt`:

	<?php namespace App\Http\Controllers;

	use Auth;
	use Illuminate\Routing\Controller;

	class AuthController extends Controller {

		/**
		 * Handle an authentication attempt.
		 *
		 * @return Response
		 */
		public function authenticate()
		{
			if (Auth::attempt(['email' => $email, 'password' => $password]))
			{
				return redirect()->intended('dashboard');
			}
		}

	}

Метод `attempt` принимает массив «ключ-значение» в качестве первого аргумента. Значения ключа `password` будет [прохэшировано](/docs/master/hashing).
Прочие значения массива используются для поиска пользователя в таблице БД. В примере выше пользователь будет выбираться по полю `email`.
Если пользователь будет найден, то хэшированный пароль из БД будет сравнён с хэшированным значение поля `password` из переданного массива.
Если два этих хэша совпадут, то для пользователя создастся новая аутентифицированная сессия.

Метод `attempt` возвращает `true`, если аутентификация прошла успешно, и `false` в противном случае.

> **Примечание:** В коде выше поле `email` не является обязательным, оно выбрано для примера.
Обычно используют какое-то поле, хранящее логин (имя пользователя) в приложении, как правило, «username».

Метод `intended` возвращает пользователя на тот адрес, доступ к которому он хотел получить, прежде чем его поймал фильтр аутентификации.
В качестве параметра в этот метод можно передать резервный адрес, если запрашиваемый адрес недоступен.

#### Аутентификация пользователя с дополнительными условиями

Вы можете добавить дополнительные условия в аутентификационный запрос:

    if (Auth::attempt(['email' => $email, 'password' => $password, 'active' => 1]))
    {
        // Аккаунта пользователя в активном режиме. 
    }

#### Как узнать, что пользователь прошел аутентфикацию?

Для проверки, аутентифицирован ли пользователь в вашем приложении, можно использовать метод `check`:

	if (Auth::check())
	{
		// Пользователь аутентифицирован...
	}

#### Аутентификация и «запоминание» пользователя

Если вы хотите разрешить пользователям использовать механизм «запомнить меня», вы можете передать булево значение вторым аргументом методу `attempt`,
что позволит сохранить статус аутентификации пользователя навсегда, либо до тех пор, пока он сам не выйдет из приложения.
Так же для этого в таблице `users` (или аналогичной) должно быть строковое поле `remember_token` длиной в 100 символов,
используемое для хранения идентификатора (токена).
На стороне пользователя идентификатор хранится в специальной куке (http cookie).

	if (Auth::attempt(['email' => $email, 'password' => $password], $remember))
	{
		// Пользователь будет «запомнен»...
	}

Если вы «запоминаете» пользователя, то можете использовать метод `viaRemember` для определения того, что пользователь аутентифицирован
с использованием этого механизма:

	if (Auth::viaRemember())
	{
		//
	}

#### Аутентификация по ID

Для аутентификации пользователя по его ID существует метод `loginUsingId`:

	Auth::loginUsingId(1);

#### Проверка прав пользователя без аутентификации

Метод `validate` позволяет проверить права пользователя без фактической аутентификации:

	if (Auth::validate($credentials))
	{
		//
	}

#### Аутентификация пользователя на время выполнения текущего запроса

Метод `once` служит для аутентификация пользователя на время выполнения текущего запроса, при этом не используются сессия и куки:

	if (Auth::once($credentials))
	{
		//
	}

#### Ручная аутентификация

Для принудительной аутентифицикации пользователя существует метод `login`:

	Auth::login($user);

Это эквивалентно аутентификации через метод метода `attempt` с передачей пользовательских параметров.

#### Выход из приложения

	Auth::logout();

Конечно, если вы используете встроенный механизм аутентификации, там это уже реализовано.

#### События при аутентификации

При вызове метода `attempt` генерируется [событие](/docs/master/events) `auth.attempt`. Если аутентификация прошла успешно
и пользователь вошёл в приложение, будет сгенерировано событие `auth.login`.

<a name="retrieving-the-authenticated-user"></a>
## Получение аутентифицированного пользователя

Как только пользователь аутентифицирован, вы можете получить объект пользователя несколькими путями.

Во-первых, с помощью фасада `Auth`:

	<?php namespace App\Http\Controllers;

	use Illuminate\Routing\Controller;

	class ProfileController extends Controller {

		/**
		 * Update the user's profile.
		 *
		 * @return Response
		 */
		public function updateProfile()
		{
			if (Auth::user())
			{
				//
			}
		}

	}

Во-вторых, через метод `user` класса `Illuminate\Http\Request`:

	<?php namespace App\Http\Controllers;

	use Illuminate\Http\Request;
	use Illuminate\Routing\Controller;

	class ProfileController extends Controller {

		/**
		 * Update the user's profile.
		 *
		 * @return Response
		 */
		public function updateProfile(Request $request)
		{
			if ($request->user())
			{
				// $request->user() возвращает объект пользователя...
			}
		}

	}

И наконец, можно использовать мощь [сервис-контейнера](/docs/master/container), указав в качестве аргумента в конструкторе
или методе контракт `Illuminate\Contracts\Auth\Authenticatable`:

	<?php namespace App\Http\Controllers;

	use Illuminate\Routing\Controller;
	use Illuminate\Contracts\Auth\Authenticatable;

	class ProfileController extends Controller {

		/**
		 * Update the user's profile.
		 *
		 * @return Response
		 */
		public function updateProfile(Authenticatable $user)
		{
			// $user это объект пользователя...
		}

	}

<a name="protecting-routes"></a>
## Ограничение доступа к роутам

Вы можете ипользовать [посредников](/docs/master/middleware) для ограничения доступа к роутам. В Laravel уже есть посредник `auth`,
находящийся в файле `app\Http\Middleware\Authenticate.php`. Всё, что вам нужно - указать его в описании нужного роута:

	// Если роут описан как замыкание...

	Route::get('profile', ['middleware' => 'auth', function()
	{
		// Доступ разрешён только аутентифицированным пользователям...
	}]);

	// Или как контроллер...

	Route::get('profile', ['middleware' => 'auth', 'uses' => 'ProfileController@show']);

<a name="http-basic-authentication"></a>
## Аутентификация на основе HTTP Basic

Аутентификация на основе HTTP Basic позволяет аутентифицировать пользователей быстро и без отдельной страницы входа.
Для этого надо указать посредника `auth.basic` в описании нужного роута :

	Route::get('profile', ['middleware' => 'auth.basic', function()
	{
		// Доступ разрешён только аутентифицированным пользователям...
	}]);

По умолчанию, посредник `auth.basic` использует поле `email` из таблицы пользователей в качестве логина (имени пользователя).

#### Setting Up A Stateless HTTP Basic Filter

Так же можно использовать аутентификацию на основе HTTP Basic без создания сессии и идентификационной куки, что часто используется
для аутентификации черех API. Для этого нужно создать [посредника](/docs/master/middleware), который будет вызывать метод `onceBasic`:

	public function handle($request, Closure $next)
	{
		return Auth::onceBasic() ?: $next($request);
	}

Если вы используете PHP в режиме FastCGI, то аутентификацию на основе HTTP Basic может не работать «из коробки». Решается эта проблема добавлением
следующих строк в файл `.htaccess`:

	RewriteCond %{HTTP:Authorization} ^(.+)$
	RewriteRule .* - [E=HTTP_AUTHORIZATION:%{HTTP:Authorization}]

<a name="password-reminders-and-reset"></a>
## Напоминание и сброс пароля

### Модель и таблица

Большинство веб-приложения позволяют пользователям сбросить забытый пароль. Laravel предоставляет удобный механизм для реализации этой возможности.

Для начала удостоверьтесь, что ваша модель `User` реализует контракт `Illuminate\Contracts\Auth\Remindable`, в том случае, если вы не используете
стандартную модель `User`, которая уже реализует это контракт с помощью трейта `Illuminate\Auth\Reminders\Remindable`.

#### Создание миграции для таблицы с напоминаниями

Далее нужно создать таблицу, хранящую токены-напоминания для сброса пароля. Эта миграция уже включена в Laravel и находится в каталоге
`database/migrations`, поэтому всё, что вам нужно сделать - выполнить команду:

	php artisan migrate

### Контроллер 

Laravel так же предоставляет контроллер `Auth\PasswordController`, содержащий необходимую логику, и шаблоны, расположенные
в каталоге `resources/views/auth`, которые вы можете изменять так, как вам нужно.

Пользователь получает письмо со ссылкой, обрабатываемой методом `getReset` в контроллере `PasswordController` 
Это метод отображает форму, где пользователь указывает новый пароль. После этого пользователь автоматически аутентифицируется
и перенаправляется на адрес `/home`. Вы можете задать свой адрес в свойстве `redirectTo` контроллера `PasswordController`:

	protected $redirectTo = '/dashboard';

> **Примечание:** По умолчанию, срок жизни токена ограничен одним часом. Вы можете изменить его, указав нужное время в опции
`reminder.expire` в файле `config/auth.php`.

<a name="social-authentication"></a>
## Аутентификация через социальные сети

В добавок к обычной аутентификации, с помощью форм и HTTP Basic, Laravel предоставляет простой и удобный механизм аутентификации
через OAuth, используя [Laravel Socialite](https://github.com/laravel/socialite).
**Socialite пока что поддерживает аутентификацию только через Facebook, Twitter, Google и GitHub.**

Что бы начать использовать Socialite, добавьте этот пакет в ваш файл `composer.json`:

	"laravel/socialite": "~2.0"

После зарегистрируйте провайдера `Laravel\Socialite\SocialiteServiceProvider` в файле `config/app.php`. Так же вы можете зарегистрировать
фасад `Socialize`:

	'Socialize' => 'Laravel\Socialite\Facades\Socialite',

Так же вам нужно указать параметры для того сервиса OAuth, который вы используете. Лучше всего делать это в файле `config/services.php`.
Пока доступно четыре сервиса: `facebook`, `twitter`, `google` и `github`. Пример:

	'github' => [
		'client_id' => 'your-github-app-id',
		'client_secret' => 'your-github-app-secret',
		'redirect' => 'http://your-callback-url',
	],

Далее нужно добавить два роута: один для перенаправления пользователя к провайдеру OAuth, второй для получения ответа от провайдера после
аутентификации пользователя. Пример с использованием фасада `Socialize`:

	public function redirectToProvider()
	{
		return Socialize::with('github')->redirect();
	}

	public function handleProviderCallback()
	{
		$user = Socialize::with('github')->user();

		// $user->token;
	}

Метод `redirect` выполнит перенаправление к провайдеру OAuth, а метод `user` получит информацию о пользователе из ответа провайдера OAuth.
Перед перенаправление вы можете указать области доступа (scopes):

	return Socialize::with('github')->scopes(['scope1', 'scope2'])->redirect();

#### Получение данных пользователя

	$user = Socialize::with('github')->user();

	// Провайдеры, использующие OAuth v.2.0
	$token = $user->token;

	// Провайдеры, использующие OAuth v.1.0
	$token = $user->token;
	$tokenSecret = $user->tokenSecret;

	// Все провайдеры
	$user->getNickname();
	$user->getName();
	$user->getEmail();
	$user->getAvatar();

